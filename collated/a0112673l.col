//@author: a0112673l



	/**
	 * origin: CEO\src\cs2103\command\AddTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.fusesource.jansi.Ansi.Color.RED;
import static org.junit.Assert.*;

import org.junit.BeforeClass;
import org.junit.Test;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.storage.TaskList;

import cs2103.parameters.ParameterList;
import cs2103.parameters.Recurrence;
import cs2103.parameters.Time;
import cs2103.task.DeadlineTask;
import cs2103.task.PeriodicTask;
import cs2103.task.Task;
import cs2103.util.TestUtil;

public class AddTest {
	
	@BeforeClass 
	public static void initialise() throws HandledException, FatalException{
		TaskList.getInstance(new Option(Option.Value.TEST)).emptyTestList();
	}
	
	@Test
	public void testAddCorrectCommand() throws HandledException, FatalException {
		assert(TaskList.getInstance()!=null);
		Add addObj;
		addObj = new Add("-title hello -description some description -location earth -time 2014/12/12 20:20 to 2014/12/15 20:20 -recur 2d");
		ParameterList pl = addObj.getParameterList();
		assertEquals("hello",pl.getTitle().getValue());
		assertEquals("some description",pl.getDescription().getValue());
		assertEquals(Time.parse("2014/12/12 20:20 to 2014/12/15 20:20").getValue()[0].toString(), pl.getTime().getValue()[0].toString());
		assertEquals(Recurrence.parse("2d").getValue().toString(), pl.getRecurrence().getValue().toString());
		addObj.execute();
		String time = "2014/12/12 20:20  to 2014/12/15 20:20";
		Task dt = new PeriodicTask(null, null, Time.parse(time).getValue()[0], Time.parse(time).getValue()[1]);
		dt.updateTitle("hello");
		dt.updateDescription("some description");
		dt.updateRecurrence(Recurrence.parse("2d").getValue());
		dt.updateLastModified(null);
		for(Task t :TaskList.getInstance().getDeadlineList()){
			if(t.getTitle().equals("hello")){
				assertTrue(TestUtil.compareTasks(t, dt));
			}
		}
	}
	
	@Test
	public void testQuickAddCommand() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		Add addObj;
		addObj = new Add("finish cs2105 assignment by next monday");
		addObj.execute();
		Task deadlineTask = new DeadlineTask(null,null,Time.parse("next monday").getValue()[0]);
		deadlineTask.updateTitle("finish cs2105 assignment ");
		deadlineTask.updateLastModified(null);
		for(Task t :TaskList.getInstance().getDeadlineList()){
			if(t.getTitle().contains("cs2105")){
				assertTrue(TestUtil.compareTasks(t, deadlineTask));
			}
		}
	}
	
	//This is a test case that combines multiple valid and invalid inputs
	@Test(expected=HandledException.class)
	public void testAddCommandInvalidParam() throws HandledException, FatalException{
		Add addObj;
		addObj = new Add("-tile hello -description was described -plave earth -time 2014/11/12");
		addObj.execute();
		Task deadlineTask = new DeadlineTask(null,null,Time.parse("2014/11/12").getValue()[0]);
		deadlineTask.updateLastModified(null);
		deadlineTask.updateDescription("was described");
		deadlineTask.updateTitle("");
		assertNull(addObj.getParameterList().getLocation());
		for(Task t :TaskList.getInstance().getDeadlineList()){
			if(t.getDescription().contains("was")){
				assertTrue(TestUtil.compareTasks(t, deadlineTask));
			}
		}
	}
	
	@SuppressWarnings("unused")
	@Test(expected = HandledException.class)
	public void testAddNullCommand() throws HandledException{
		Add addObj = new Add(null);
	}

	//tests undo redo function for add command
	@Test
	public void testAddUndoRedo() throws HandledException, FatalException{
		Add addObj = new Add("-title undo");
		addObj.execute();
		addObj.undo();
		Search s = new Search("undo");
		String result = s.execute().toString();
		assertEquals(ansi().bold().fg(RED).a("The task list is empty\n").reset().toString(),result);
		addObj.redo();
		result = s.execute().toString();
		Task t = TaskList.getInstance().getFloatingList().get(0);
		addObj.undo();
		assertEquals(ansi().a(t.toSummary()).a('\n').toString(),result);
	}
}

	// End of segment: CEO\src\cs2103\command\AddTest.java





	/**
	 * origin: CEO\src\cs2103\command\Alert.java
	 */

package cs2103.command;

import java.util.ArrayList;

import org.fusesource.jansi.Ansi;

import static org.fusesource.jansi.Ansi.*;
import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.storage.TaskList;
import cs2103.task.DeadlineTask;
import cs2103.task.PeriodicTask;
import cs2103.util.Logger;

public class Alert extends QueryCommand {
	private static final String MESSAGE_TASKS_DUE = "Tasks due within one day:\n";
	private static final String MESSAGE_TASKS_STARTING = "Tasks start within one day:\n";
	private static final String LOG_ALERT = "Executing Alert";
	
	@Override
	public Ansi execute() throws HandledException, FatalException {	
		Logger.getInstance().writeLog(LOG_ALERT);
		Ansi returnString = ansi().a(MESSAGE_TASKS_DUE);
		returnString.a(parseListResponse(this.alertDeadline()));
		returnString.a(MESSAGE_TASKS_STARTING);
		returnString.a(parseListResponse(this.alertPeriodic()));
		return returnString;
	}
	
	/**Returns list of DeadlineTask due within a day
	 * @return ArrayList of DeadlineTasks
	 * @throws HandledException
	 * @throws FatalException
	 */
	private ArrayList<DeadlineTask> alertDeadline() throws HandledException, FatalException {
		ArrayList<DeadlineTask> taskList = TaskList.getInstance().getDeadlineList();
		ArrayList<DeadlineTask> returnList = new ArrayList<DeadlineTask>();
		for (DeadlineTask task:taskList) {
			if (task.checkAlert()) {
				returnList.add(task);
			}
		}
		return returnList;
	}

	/**
	 * Returns list of PeriodicTask due starting within one day
	 * @return ArrayList of PeriodicTask
	 * @throws HandledException
	 * @throws FatalException
	 */
	private ArrayList<PeriodicTask> alertPeriodic() throws HandledException, FatalException {
		ArrayList<PeriodicTask> taskList = TaskList.getInstance().getPeriodicList();
		ArrayList<PeriodicTask> returnList = new ArrayList<PeriodicTask>();
		for (PeriodicTask task:taskList) {
			if (task.checkAlert()) {
				returnList.add(task);
			}
		}
		return returnList;
	}

}

	// End of segment: CEO\src\cs2103\command\Alert.java





	/**
	 * origin: CEO\src\cs2103\command\DeleteTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.fusesource.jansi.Ansi.Color.MAGENTA;
import static org.fusesource.jansi.Ansi.Color.RED;
import static org.junit.Assert.*;

import org.junit.BeforeClass;
import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.storage.TaskList;
import cs2103.parameters.ParameterList;
import cs2103.task.FloatingTask;
import cs2103.task.Task;
import cs2103.util.TestUtil;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class DeleteTest {

	@BeforeClass
	public static void initialise() throws HandledException, FatalException{
		TaskList.getInstance(new Option(Option.Value.TEST)).emptyTestList();;
	}
	
	@Test
	public void test1_testPermanentDelete() throws HandledException, FatalException {
		assert(TaskList.getInstance()!=null);
		Add addObj = new Add("-title testDelete");
		addObj.execute();
		Delete deleteObj = new Delete("1 -p");
		ParameterList pl = deleteObj.getParameterList();
		assertEquals(true,pl.getDeleteOption().getValue());
		assertEquals(1,pl.getTaskID().getValue());
		String result = deleteObj.execute().toString();
		assertEquals(ansi().fg(MAGENTA).a("You have permanently deleted task with ID 1\n").reset().toString(),result);
		
	}
	
	//This test test temp delete with one valid input (taskiD - 1) and one invalid input (param - m)
	@Test
	public void test2_testTempDelete() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		Add addObj = new Add("-title tempDelete");
		addObj.execute();
		Delete deleteObj = new Delete("1 -m");
		deleteObj.execute();
		Task task = new FloatingTask(null, null);
		task.updateDescription(null);
		task.updateLastModified(null);
		for(Task t : TaskList.getInstance().getTrashList()){
			TestUtil.compareTasks(task, t);
		}
	}
	
	@Test(expected = HandledException.class)
	public void test3_testInvalidDelete() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		Delete deleteObj = new Delete("2");
		deleteObj.execute();
	}
	
	@Test
	public void test4_testUndoRedo() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		Add addObj = new Add("-title testDelete");
		addObj.execute();
		Delete deleteObj = new Delete("2");
		deleteObj.execute();
		deleteObj.undo();
		Search s = new Search("testDelete");
		String result = s.execute().toString();
		assertNotEquals(ansi().bold().fg(RED).a("The task list is empty\n").reset().toString(),result);
		deleteObj.redo();
		result = s.execute().toString();
		assertEquals(ansi().bold().fg(RED).a("The task list is empty\n").reset().toString(),result);
	}

}

	// End of segment: CEO\src\cs2103\command\DeleteTest.java





	/**
	 * origin: CEO\src\cs2103\command\Help.java
	 */

package cs2103.command;

import org.fusesource.jansi.Ansi;
import cs2103.exception.HandledException;
import cs2103.parameters.CommandType;
import cs2103.util.CommonUtil;
import static org.fusesource.jansi.Ansi.*;
import static org.fusesource.jansi.Ansi.Color.*;

public class Help extends QueryCommand {
	public static final Ansi HELP_DEFAULT = ansi().fg(YELLOW).a("CEO Usage:\n").reset()
            								  .bold().a("  add <Quick add string>\n" +
            										    "      ([-S or --title <title>] [-D or -description <description>]\n" + 
            										    "      [-L or -location <location>] [-R or -recurring <number h/d/w/m/y>]\n" +
            										    "      [-T or -time {<blank>|<time>|<<time> to <time>>}])\n").reset()
            								.bg(BLUE).a("  +Add a new task. Enter \"help add\" for more\n\n").reset()
            								  .bold().a("  list (<floating|deadline|periodic|all|trash>)\n").reset()
            							   .bg(GREEN).a("  +List existing tasks. Enter \"help list\" for more\n\n").reset()
            								  .bold().a("  show <task ID>\n").reset()
            							   .bg(GREEN).a("  +Show detail of the task with specified task ID. Enter \"help show\" for more\n\n").reset()
            								  .bold().a("  delete <task ID> (-p)\n").reset()
            								 .bg(RED).a("  +Delete task with corresponding taskID. Enter \"help delete\" for more\n\n").reset()
            								  .bold().a("  update <task ID> ([-S or -title <title>] [-C or -complete {true|false}]\n" +
            										  	"                   [-D or -description <description>]\n" +
            										  	"                   [-L or -location <location>]\n" +
            										  	"                   [-T or -time {<blank>|<time>|<<time> to <time>>}]\n" +
            										  	"                   [-R or -recurring <number h/d/w/m/y>])\n").reset()
            								.bg(BLUE).a("  +Update task with corresponding task ID. Enter \"help update\" for more\n\n").reset()
            								  .bold().a("  undo/redo <number of steps>\n").reset()
            								.bg(BLUE).a("  +Undo/redo some steps. Enter \"help undo\" or \"help redo\" for more\n\n").reset()
            								  .bold().a("  search (<keyword String>)\n" +
            								  "         {([-K or -type <floating|deadline|periodic|all|trash>]\n" +
            								  "         [-C or -complete {true|false}]\n" +
            								  "         [-T or -time {<blank>|<time>|<<time> to <time>>}]}\n").reset()
            								.bg(GREEN).a("  +Search for tasks. Enter \"help search\" for more\n\n").reset()
            								  .bold().a("  mark <task ID>\n").reset()
            								.bg(BLUE).a("  Mark a task as completed. Enter \"help mark\" for more\n\n").reset()
            								  .bold().a("  sync (-disable)\n").reset()
            								.bg(BLUE).a("  +Manually sync your task with Google. In usual circumstances, CEO will\n" +
            											"   automatically sync with Google, this command is useful when you disabled\n" +
            											"   sync in initialization\n" +
            											"   Use sync -disable to disable syncing\n\n").reset()
            								  .bold().a("  alert\n").reset()
            								.bg(BLUE).a("  +display approaching deadlines and start times\n\n").reset()
            								  .bold().a("  help\n").reset()
            								.bg(BLUE).a("  +display this message\n").reset();
	public static final Ansi HELP_ADD = ansi().a("Add usage:\n")
							    .bold().a("  add <Quick add string>\n" +
										  "      ([-S or --title <title>] [-D or -description <description>]\n" + 
										  "      [-L or -location <location>] [-R or -recurring <number h/d/w/m/y>]\n" +
										  "      [-T or -time {<blank>|<time>|<<time> to <time>>}])\n").reset()
									   .a("Options:\n")
						      .bg(CYAN).a("  <Quick add string>          Text before \"from\"/\"by\"/\"on\"/\"in\"/\"at\" is title.\n" +
										  "                              You can specify time after these keywords.\n" +
										  "                              Specify recurrence after keyword \"every\"\n" +
										  "  -title <taskTitle>          Optional if using quick add, title of the task\n" +
										  "  -description <description>  Optional, describe task details\n" +
										  "  -location <location>        Optional, describe task location\n" +
										  "                              Only available for periodic tasks\n" +
										  "  -time <blank>               default, no time info.\n" +
										  "                              This task is a floating task.\n" +
										  "        <time>                define a deadline for the task.\n" +
										  "                              This task is a deadline task\n" +
										  "        <<time> to <time>>    define time period for the task.\n" +
										  "                              This is a periodic task\n" +
										  "  -recurring <Interval><Frequency> Optional, define a recurrence period\n" +
										  "                       <Frequency> can be h/d/w/m/y, refers to:\n" +
										  "                       Every <Interval> (h)ours/(d)ays/(w)eek/(m)onth/(y)ear\n\n").reset()
									   .a("Example:\n")
					        .bg(YELLOW).a("  add Submit homework by tomorrow\n").reset()
							  .bg(BLUE).a("This will effectively adding a Deadline Task with title \"Submit homework\" with due time by tomorrow\n\n").reset()
							.bg(YELLOW).a("  add -title Task Title -description Describe this task -location office\n" +
										  "      -time 2014/10/12 14:22 to 2014/10/13 14:22 -recurring 1w\n").reset()
							  .bg(BLUE).a("This will effectively adding a Periodic task with title \"Task Title\", with description \"Describe this task\", with location \"office\", with a time period from 2014/10/12 14:22 to 2014/10/13 14:22, and this task will recur every 1 week\n").reset();
	public static final Ansi HELP_DELETE = ansi().a("Delete usage:\n")
								   .bold().a("  delete <task ID> (-p)\n").reset()
										  .a("Options:\n")
						         .bg(CYAN).a("  <task ID>        Elementary, specify the task you want to move to trash\n" +
										  	 "  -p               Optional, the task will be removed permanantly\n").reset()
						       .bg(YELLOW).a("Example: delete 1\n").reset();
	public static final Ansi HELP_UPDATE = ansi().a("Update usage:\n")
								   .bold().a("  update <task ID> ([-S or -title <title>] [-C or -complete {true|false}]\n" +
											 "                   [-D or -description <description>]\n" +
											 "                   [-L or -location <location>]\n" +
											 "                   [-T or -time {<blank>|<time>|<<time> to <time>>}]\n" +
											 "                   [-R or -recurring <number h/d/w/m/y>])\n").reset()
			 							  .a("Options:\n")
			 			         .bg(CYAN).a("  <Task ID>                   Elementary, specify the task ID of which\n" +
			 								 "                              the task require modification\n" +
			 								 "  -title <taskTitle>          Modify title of the task\n" +
			 								 "  -complete <true|false>      Indicate the task is complete or not\n" +
			 								 "                              Unavailable for periodic tasks\n" +
			 								 "  -description <description>  Modify task details\n" +
			 								 "  -location <location>        Modify task location\n" +
			 								 "                              only available for periodic tasks\n" +
			 								 "  -time <blank>               Convert this task to a floating task\n" +
			 								 "        <time>                Convert this task to a deadline task\n" +
			 								 "        <<time> to <time>>    Convert this task to a periodic task\n" +
			 								 "  -recurring <Interval><Frequency> Modify the recurrence period\n" +
			 								 "                       <Frequency> can be h/d/w/m/y, refers to:\n" +
			 								 "                       Every <Interval> (h)ours/(d)ays/(w)eek/(m)onth/(y)ear\n" +
			 								 "                       Use -recurring 0 to remove the recurrence\n\n").reset()
			 							  .a("Example:\n")
			 			       .bg(YELLOW).a("  update 1 -title Task Title -description Describe this task\n" +
			 								 "           -time 2014/10/12 -complete true\n").reset()
			 				     .bg(BLUE).a("This will effectively update the task with Task ID 1 to a Deadline task with title \"Task Title\", with description \"Describe this task\", with a deadline at 2014/10/12 and indicate the task is complete\n").reset();
	public static final Ansi HELP_LIST = ansi().a("List usage:\n")
								 .bold().a("list (<<blank>|floating|deadline|periodic|all>)\n" +
										   "  <blank>              list only incomplete tasks\n" +
										   "  floating             list tasks with no dates set\n" +
										   "  deadline             list tasks that have a deadline\n" +
										   "  periodic             list tasks that is a timed event\n" +
										   "  all                  list all tasks\n" +
										   "  trash                list all tasks in trash bin\n").reset()
							 .bg(YELLOW).a("Example:\nlist deadline\n").reset();
	public static final Ansi HELP_SHOW = ansi().bold().a("Show has no extra options\n" +
										   "Example:\nshow 1\n").reset();
	public static final Ansi HELP_REDO = ansi().bold().a("Redo has no extra options\n" +
										   "Example:\nredo 1\n").reset();
	public static final Ansi HELP_UNDO = ansi().bold().a("Undo has no extra options\n" +
										   "Example:\nundo 1\n").reset();
	public static final Ansi HELP_SEARCH = ansi().a("Search usage:\n")
								   .bold().a("  search (<keyword String>)\n" +
											 "         {([-K or -type <floating|deadline|periodic|all|trash>]\n" +
											 "         [-C or -complete {true|false}]\n" +
											 "         [-T or -time {<blank>|<time>|<<time> to <time>>}]}\n").reset()
			 							  .a("Options:\n")
			 			         .bg(CYAN).a("  <Keyword>                   Search title, description and location\n" +
			 								 "                              for the specified keyword\n" +
			 								 "  <floating|deadline|         Specify the type of tasks to search\n" +
			 								 "  periodic|all|trash>         if not specified, search all tasks\n" +
			 								 "  -complete <true|false>      Specify the complete status you want to search\n" +
			 								 "  -time <blank>               Search only deadline and periodic tasks\n" +
			 								 "        <time>                Search deadline and periodic tasks that\n" +
			 								 "                              due time or start time is before given time\n" +
			 								 "        <<time> to <time>>    Search deadline and periodic tasks that \n" +
			 								 "                              due time or start time is within given period\n\n").reset()
			 							  .a("Example:\n")
			 			       .bg(YELLOW).a("  search example keyword -keyword all -complete true -time\n").reset()
			 			         .bg(BLUE).a("This will effectively return the completed Deadline tasks which title, description or location contains \"example keyword\". (when complete parameter is specified, it is implied that all Periodic Tasks will be excluded)\n").reset();
	public static final Ansi HELP_MARK = ansi().bold().a("Mark has no extra options\n" +
			 							   "Example: mark 2\n").reset();
	
	/**
	 * Creates an instance of Help from String command
	 * @param command
	 */
	public Help(String command) {
		this.parameterList.addParameter(CommandType.parse(command));
	}
	
	@Override
	public Ansi execute() throws HandledException {
		CommonUtil.checkNull(this.parameterList.getCommandType(), HandledException.ExceptionType.INVALID_CMD);
		switch (parameterList.getCommandType().getValue()) {
		case LIST:
			return HELP_LIST;
		case UPDATE:
			return HELP_UPDATE;
		case ADD:
			return HELP_ADD;
		case DELETE:
			return HELP_DELETE;
		case SHOW:
			return HELP_SHOW;
		case UNDO:
			return HELP_UNDO;
		case REDO:
			return HELP_REDO;
		case SEARCH:
			return HELP_SEARCH;
		case MARK:
			return HELP_MARK;
		case INVALID:
		default:
			return HELP_DEFAULT;
		}
	}

}

	// End of segment: CEO\src\cs2103\command\Help.java





	/**
	 * origin: CEO\src\cs2103\command\HelpTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.fusesource.jansi.Ansi.Color.BLUE;
import static org.fusesource.jansi.Ansi.Color.CYAN;
import static org.fusesource.jansi.Ansi.Color.GREEN;
import static org.fusesource.jansi.Ansi.Color.RED;
import static org.fusesource.jansi.Ansi.Color.YELLOW;
import static org.junit.Assert.*;

import org.fusesource.jansi.Ansi;
import org.junit.Test;

import cs2103.exception.HandledException;

public class HelpTest {
	public static final Ansi HELP_DEFAULT = ansi().fg(YELLOW).a("CEO Usage:\n").reset()
			  .bold().a("  add <Quick add string>\n" +
					    "      ([-S or --title <title>] [-D or -description <description>]\n" + 
					    "      [-L or -location <location>] [-R or -recurring <number h/d/w/m/y>]\n" +
					    "      [-T or -time {<blank>|<time>|<<time> to <time>>}])\n").reset()
			.bg(BLUE).a("  +Add a new task. Enter \"help add\" for more\n\n").reset()
			  .bold().a("  list (<floating|deadline|periodic|all|trash>)\n").reset()
		   .bg(GREEN).a("  +List existing tasks. Enter \"help list\" for more\n\n").reset()
			  .bold().a("  show <task ID>\n").reset()
		   .bg(GREEN).a("  +Show detail of the task with specified task ID. Enter \"help show\" for more\n\n").reset()
			  .bold().a("  delete <task ID> (-p)\n").reset()
			 .bg(RED).a("  +Delete task with corresponding taskID. Enter \"help delete\" for more\n\n").reset()
			  .bold().a("  update <task ID> ([-S or -title <title>] [-C or -complete {true|false}]\n" +
					  	"                   [-D or -description <description>]\n" +
					  	"                   [-L or -location <location>]\n" +
					  	"                   [-T or -time {<blank>|<time>|<<time> to <time>>}]\n" +
					  	"                   [-R or -recurring <number h/d/w/m/y>])\n").reset()
			.bg(BLUE).a("  +Update task with corresponding task ID. Enter \"help update\" for more\n\n").reset()
			  .bold().a("  undo/redo <number of steps>\n").reset()
			.bg(BLUE).a("  +Undo/redo some steps. Enter \"help undo\" or \"help redo\" for more\n\n").reset()
			  .bold().a("  search (<keyword String>)\n" +
			  "         {([-K or -type <floating|deadline|periodic|all|trash>]\n" +
			  "         [-C or -complete {true|false}]\n" +
			  "         [-T or -time {<blank>|<time>|<<time> to <time>>}]}\n").reset()
			.bg(GREEN).a("  +Search for tasks. Enter \"help search\" for more\n\n").reset()
			  .bold().a("  mark <task ID>\n").reset()
			.bg(BLUE).a("  Mark a task as completed. Enter \"help mark\" for more\n\n").reset()
			  .bold().a("  sync (-disable)\n").reset()
			.bg(BLUE).a("  +Manually sync your task with Google. In usual circumstances, CEO will\n" +
						"   automatically sync with Google, this command is useful when you disabled\n" +
						"   sync in initialization\n" +
						"   Use sync -disable to disable syncing\n\n").reset()
			  .bold().a("  alert\n").reset()
			.bg(BLUE).a("  +display approaching deadlines and start times\n\n").reset()
			  .bold().a("  help\n").reset()
			.bg(BLUE).a("  +display this message\n").reset();
public static final Ansi HELP_ADD = ansi().a("Add usage:\n")
.bold().a("  add <Quick add string>\n" +
		  "      ([-S or --title <title>] [-D or -description <description>]\n" + 
		  "      [-L or -location <location>] [-R or -recurring <number h/d/w/m/y>]\n" +
		  "      [-T or -time {<blank>|<time>|<<time> to <time>>}])\n").reset()
	   .a("Options:\n")
.bg(CYAN).a("  <Quick add string>          Text before \"from\"/\"by\"/\"on\"/\"in\"/\"at\" is title.\n" +
		  "                              You can specify time after these keywords.\n" +
		  "                              Specify recurrence after keyword \"every\"\n" +
		  "  -title <taskTitle>          Optional if using quick add, title of the task\n" +
		  "  -description <description>  Optional, describe task details\n" +
		  "  -location <location>        Optional, describe task location\n" +
		  "                              Only available for periodic tasks\n" +
		  "  -time <blank>               default, no time info.\n" +
		  "                              This task is a floating task.\n" +
		  "        <time>                define a deadline for the task.\n" +
		  "                              This task is a deadline task\n" +
		  "        <<time> to <time>>    define time period for the task.\n" +
		  "                              This is a periodic task\n" +
		  "  -recurring <Interval><Frequency> Optional, define a recurrence period\n" +
		  "                       <Frequency> can be h/d/w/m/y, refers to:\n" +
		  "                       Every <Interval> (h)ours/(d)ays/(w)eek/(m)onth/(y)ear\n\n").reset()
	   .a("Example:\n")
.bg(YELLOW).a("  add Submit homework by tomorrow\n").reset()
.bg(BLUE).a("This will effectively adding a Deadline Task with title \"Submit homework\" with due time by tomorrow\n\n").reset()
.bg(YELLOW).a("  add -title Task Title -description Describe this task -location office\n" +
		  "      -time 2014/10/12 14:22 to 2014/10/13 14:22 -recurring 1w\n").reset()
.bg(BLUE).a("This will effectively adding a Periodic task with title \"Task Title\", with description \"Describe this task\", with location \"office\", with a time period from 2014/10/12 14:22 to 2014/10/13 14:22, and this task will recur every 1 week\n").reset();
public static final Ansi HELP_DELETE = ansi().a("Delete usage:\n")
 .bold().a("  delete <task ID> (-p)\n").reset()
		  .a("Options:\n")
.bg(CYAN).a("  <task ID>        Elementary, specify the task you want to move to trash\n" +
		  	 "  -p               Optional, the task will be removed permanantly\n").reset()
.bg(YELLOW).a("Example: delete 1\n").reset();
public static final Ansi HELP_UPDATE = ansi().a("Update usage:\n")
 .bold().a("  update <task ID> ([-S or -title <title>] [-C or -complete {true|false}]\n" +
			 "                   [-D or -description <description>]\n" +
			 "                   [-L or -location <location>]\n" +
			 "                   [-T or -time {<blank>|<time>|<<time> to <time>>}]\n" +
			 "                   [-R or -recurring <number h/d/w/m/y>])\n").reset()
		  .a("Options:\n")
.bg(CYAN).a("  <Task ID>                   Elementary, specify the task ID of which\n" +
			 "                              the task require modification\n" +
			 "  -title <taskTitle>          Modify title of the task\n" +
			 "  -complete <true|false>      Indicate the task is complete or not\n" +
			 "                              Unavailable for periodic tasks\n" +
			 "  -description <description>  Modify task details\n" +
			 "  -location <location>        Modify task location\n" +
			 "                              only available for periodic tasks\n" +
			 "  -time <blank>               Convert this task to a floating task\n" +
			 "        <time>                Convert this task to a deadline task\n" +
			 "        <<time> to <time>>    Convert this task to a periodic task\n" +
			 "  -recurring <Interval><Frequency> Modify the recurrence period\n" +
			 "                       <Frequency> can be h/d/w/m/y, refers to:\n" +
			 "                       Every <Interval> (h)ours/(d)ays/(w)eek/(m)onth/(y)ear\n" +
			 "                       Use -recurring 0 to remove the recurrence\n\n").reset()
		  .a("Example:\n")
.bg(YELLOW).a("  update 1 -title Task Title -description Describe this task\n" +
			 "           -time 2014/10/12 -complete true\n").reset()
.bg(BLUE).a("This will effectively update the task with Task ID 1 to a Deadline task with title \"Task Title\", with description \"Describe this task\", with a deadline at 2014/10/12 and indicate the task is complete\n").reset();
public static final Ansi HELP_LIST = ansi().a("List usage:\n")
.bold().a("list (<<blank>|floating|deadline|periodic|all>)\n" +
		   "  <blank>              list only incomplete tasks\n" +
		   "  floating             list tasks with no dates set\n" +
		   "  deadline             list tasks that have a deadline\n" +
		   "  periodic             list tasks that is a timed event\n" +
		   "  all                  list all tasks\n" +
		   "  trash                list all tasks in trash bin\n").reset()
.bg(YELLOW).a("Example:\nlist deadline\n").reset();
public static final Ansi HELP_SHOW = ansi().bold().a("Show has no extra options\n" +
		   "Example:\nshow 1\n").reset();
public static final Ansi HELP_REDO = ansi().bold().a("Redo has no extra options\n" +
		   "Example:\nredo 1\n").reset();
public static final Ansi HELP_UNDO = ansi().bold().a("Undo has no extra options\n" +
		   "Example:\nundo 1\n").reset();
public static final Ansi HELP_SEARCH = ansi().a("Search usage:\n")
 .bold().a("  search (<keyword String>)\n" +
			 "         {([-K or -type <floating|deadline|periodic|all|trash>]\n" +
			 "         [-C or -complete {true|false}]\n" +
			 "         [-T or -time {<blank>|<time>|<<time> to <time>>}]}\n").reset()
		  .a("Options:\n")
.bg(CYAN).a("  <Keyword>                   Search title, description and location\n" +
			 "                              for the specified keyword\n" +
			 "  <floating|deadline|         Specify the type of tasks to search\n" +
			 "  periodic|all|trash>         if not specified, search all tasks\n" +
			 "  -complete <true|false>      Specify the complete status you want to search\n" +
			 "  -time <blank>               Search only deadline and periodic tasks\n" +
			 "        <time>                Search deadline and periodic tasks that\n" +
			 "                              due time or start time is before given time\n" +
			 "        <<time> to <time>>    Search deadline and periodic tasks that \n" +
			 "                              due time or start time is within given period\n\n").reset()
		  .a("Example:\n")
.bg(YELLOW).a("  search example keyword -keyword all -complete true -time\n").reset()
.bg(BLUE).a("This will effectively return the completed Deadline tasks which title, description or location contains \"example keyword\". (when complete parameter is specified, it is implied that all Periodic Tasks will be excluded)\n").reset();
public static final Ansi HELP_MARK = ansi().bold().a("Mark has no extra options\n" +
		   "Example: mark 2\n").reset();


	@Test
	public void testDefaultHelp() throws HandledException {
		Help defaultHelp = new Help("help");
		assertEquals(HELP_DEFAULT.toString(),defaultHelp.execute().toString());
	}
	
	@Test
	public void testAddHelp() throws HandledException{
		Help addHelp = new Help("add");
		assertEquals(HELP_ADD.toString(),addHelp.execute().toString());
	}
	
	@Test
	public void testDeleteHelp() throws HandledException{
		Help deleteHelp = new Help("delete");
		assertEquals(HELP_DELETE.toString(),deleteHelp.execute().toString());
	}
	
	@Test
	public void testUpdateHelp() throws HandledException{
		Help updateHelp = new Help("update");
		assertEquals(HELP_UPDATE.toString(),updateHelp.execute().toString());
	}

	@Test
	public void testListHelp() throws HandledException{
		Help listHelp = new Help("list");
		assertEquals(HELP_LIST.toString(),listHelp.execute().toString());
	}
	
	@Test
	public void testShowHelp() throws HandledException{
		Help showHelp = new Help("show");
		assertEquals(HELP_SHOW.toString(),showHelp.execute().toString());
	}
	
	@Test
	public void testRedoHelp() throws HandledException{
		Help redoHelp = new Help("redo");
		assertEquals(HELP_REDO.toString(),redoHelp.execute().toString());
	}
	
	@Test
	public void testUndoHelp() throws HandledException{
		Help undoHelp = new Help("undo");
		assertEquals(HELP_UNDO.toString(), undoHelp.execute().toString());
	}
	
	@Test
	public void testSearchHelp() throws HandledException{
		Help searchHelp = new Help("search");
		assertEquals(HELP_SEARCH.toString(), searchHelp.execute().toString());
	}
	
	@Test
	public void testMarkHelp() throws HandledException{
		Help markHelp = new Help("mark");
		assertEquals(HELP_MARK.toString(), markHelp.execute().toString());
	}
}
	// End of segment: CEO\src\cs2103\command\HelpTest.java





	/**
	 * origin: CEO\src\cs2103\command\List.java
	 */

package cs2103.command;

import org.fusesource.jansi.Ansi;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.TaskType;
import cs2103.storage.TaskList;
import cs2103.util.CommonUtil;
import cs2103.util.Logger;

public class List extends QueryCommand {
	private static final String LOG_LIST = "Executing List: Parameters: TaskType: %1$s";
	/**
	 * Creates an instance of List from user input
	 * @param command
	 */
	public List(String command) {
		this.parameterList.addParameter(TaskType.parse(command));
	}
	
	@Override
	public Ansi execute() throws HandledException, FatalException {
		CommonUtil.checkNull(this.parameterList.getTaskType(), HandledException.ExceptionType.INVALID_CMD);
		Logger.getInstance().writeLog(this.formatLogString());
		switch (this.parameterList.getTaskType().getValue()) {
		case FLOATING:
			return parseListResponse(TaskList.getInstance().getFloatingList());
		case DEADLINE:
			return parseListResponse(TaskList.getInstance().getDeadlineList());
		case PERIODIC:
			return parseListResponse(TaskList.getInstance().getPeriodicList());
		case ALL:
			return parseListResponse(TaskList.getInstance().getAllList());
		case TRASH:
			return parseListResponse(TaskList.getInstance().getTrashList());
		case DEFAULT:
		case INVALID:
		default:
			return parseListResponse(TaskList.getInstance().getDefaultList());
		}
	}

	private String formatLogString() throws HandledException {
		return String.format(LOG_LIST, this.parameterList.getTaskType().getValue().toString());
	}
}

	// End of segment: CEO\src\cs2103\command\List.java





	/**
	 * origin: CEO\src\cs2103\command\ListTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.fusesource.jansi.Ansi.Color.RED;
import static org.junit.Assert.*;

import org.junit.BeforeClass;
import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.storage.TaskList;
import cs2103.task.Task;
import cs2103.parameters.ParameterList;
import cs2103.parameters.TaskType.Value;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class ListTest {

	@BeforeClass
	public static void initialise() throws HandledException, FatalException{
		TaskList.getInstance(new Option(Option.Value.TEST)).emptyTestList();;		
	}
	
	@Test
	public void test1_testEmptyList() throws FatalException, HandledException{
		assert(TaskList.getInstance()!=null);
		List listEmpty = new List("all");
		String result = listEmpty.execute().toString();
		assertEquals(ansi().bold().fg(RED).a("The task list is empty\n").reset().toString(),result);
	}
	
	//This test checks output for invalid input
	@Test
	public void test2_testDefaultlist() throws FatalException, HandledException{
		assert(TaskList.getInstance()!=null);
		Add addObj = new Add("add -title floating");
		addObj.execute();
		addObj = new Add("add -title deadline -time 2014/11/23 20:20");
		addObj.execute();
		addObj = new Add("add -title periodic -time 2014/11/23 20:20 to 2014/11/25 20:20");
		addObj.execute();
		List listDefault = new List("hello");
		ParameterList pl = listDefault.getParameterList();
		assertEquals(Value.INVALID,pl.getTaskType().getValue());
		String result = listDefault.execute().toString();
		Task t = TaskList.getInstance().getFloatingList().get(0);
		Task t2 = TaskList.getInstance().getDeadlineList().get(0);
		Task t3 = TaskList.getInstance().getPeriodicList().get(0);
		assertEquals(ansi().a(t.toSummary()).a("\n").a(t2.toSummary())
				.a("\n").a(t3.toSummary()).a("\n").toString(),result);
	}
	
	@Test
	public void test3_testAllist() throws FatalException, HandledException{
		assert(TaskList.getInstance()!=null);
		List listDefault = new List("all");
		ParameterList pl = listDefault.getParameterList();
		assertEquals(Value.ALL,pl.getTaskType().getValue());
		String result = listDefault.execute().toString();
		Task t = TaskList.getInstance().getFloatingList().get(0);
		Task t2 = TaskList.getInstance().getDeadlineList().get(0);
		Task t3 = TaskList.getInstance().getPeriodicList().get(0);
		assertEquals(ansi().a(t.toSummary()).a("\n").a(t2.toSummary())
				.a("\n").a(t3.toSummary()).a("\n").toString(),result);
	}
	
	@Test
	public void test4_testPeriodicList() throws FatalException, HandledException{
		assert(TaskList.getInstance()!=null);
		List listPeriodic = new List("periodic");
		ParameterList pl = listPeriodic.getParameterList();
		assertEquals(Value.PERIODIC,pl.getTaskType().getValue());
		String result = listPeriodic.execute().toString();
		Task t3 = TaskList.getInstance().getPeriodicList().get(0);
		assertEquals(ansi().a(t3.toSummary()).a("\n").toString(),result);
	}
	
	@Test
	public void test5_testDeadlineList() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		List listDeadline = new List("deadline");
		ParameterList pl = listDeadline.getParameterList();
		assertEquals(Value.DEADLINE,pl.getTaskType().getValue());
		String result = listDeadline.execute().toString();
		Task t2 = TaskList.getInstance().getDeadlineList().get(0);
		assertEquals(ansi().a(t2.toSummary()).a("\n").toString(),result);
	}
	
	@Test
	public void test6_testFloatingList() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		List listFloating = new List("floating");
		ParameterList pl = listFloating.getParameterList();
		assertEquals(Value.FLOATING,pl.getTaskType().getValue());
		String result = listFloating.execute().toString();
		Task t = TaskList.getInstance().getFloatingList().get(0);
		assertEquals(ansi().a(t.toSummary()).a("\n").toString(),result);
	}

}

	// End of segment: CEO\src\cs2103\command\ListTest.java





	/**
	 * origin: CEO\src\cs2103\command\MarkTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.fusesource.jansi.Ansi.Color.RED;
import static org.junit.Assert.*;

import java.util.Date;

import org.junit.BeforeClass;
import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.storage.TaskList;

import cs2103.parameters.ParameterList;
import cs2103.parameters.Time;
import cs2103.task.DeadlineTask;
import cs2103.task.FloatingTask;
import cs2103.task.Task;
import cs2103.util.TestUtil;


@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class MarkTest {
	static Date d = null;
	
	@BeforeClass
	public static void initialise() throws HandledException, FatalException{
		TaskList.getInstance(new Option(Option.Value.TEST)).emptyTestList();;
		
	}
	
	@Test
	public void test1_FloatingTask_Mark() throws HandledException, FatalException {
		Add addObj = new Add("-title floating");
		addObj.execute();
		Mark markFloating = new Mark("1");
		d = new Date();
		ParameterList pl = markFloating.getParameterList();
		assertEquals(1,pl.getTaskID().getValue());
		Task ft = new FloatingTask(null, null);
		ft.updateTitle("floating");
		ft.updateDescription(null);
		ft.updateLastModified(null);
		ft.updateCompleted(d);
		markFloating.execute();
		for(Task t : TaskList.getInstance().getFloatingList()){
			if(t.getTitle().toString().equals("floating")){
				assertTrue(TestUtil.compareTasks(t, ft));
			}
		}
	}
	
	@Test
	public void test3_PeriodicTask_Mark() throws HandledException, FatalException{
		Add addObj = new Add("-title periodic -time 2014/10/23 20:20 to 2014/10/25 20:20");
		addObj.execute();
		Mark markPeriodic = new Mark("3");
		d = new Date();
		ParameterList pl = markPeriodic.getParameterList();
		assertEquals(3,pl.getTaskID().getValue());
		String result = markPeriodic.execute().toString();
		//unable to replace with compareTask as periodic has no complete flag
		assertEquals(ansi().fg(RED).a("Task 3 does not support mark operation\n").reset().toString(),result);
	}
	
	@Test
	public void test2_DeadlineTask_Mark() throws HandledException, FatalException{
		Add addObj = new Add("-title deadline -time 2014/10/23 20:20");
		addObj.execute();
		Mark markDeadline = new Mark("2");
		d = new Date();
		ParameterList pl = markDeadline.getParameterList();
		assertEquals(2,pl.getTaskID().getValue());
		markDeadline.execute();
		String time ="2014/10/23 20:20";
		Task pt = new DeadlineTask(null, null, Time.parse(time).getValue()[0]);
		pt.updateTitle("deadline");
		pt.updateDescription(null);
		pt.updateLastModified(null);
		pt.updateCompleted(d);
		markDeadline.execute();
		for(Task t: TaskList.getInstance().getDeadlineList()){
			assertTrue(TestUtil.compareTasks(t, pt));
		}
	}
	
	@Test 
	public void test4_UndoRedoTask_Mark() throws HandledException, FatalException{
		Add addObj = new Add("-title mark");
		addObj.execute();
		Mark markFloating = new Mark("4");
		d = new Date();
		markFloating.execute();
		markFloating.undo();
		Task ft = new FloatingTask(null, null);
		ft.updateTitle("mark");
		ft.updateDescription(null);
		ft.updateLastModified(null);
		ft.updateCompleted(d);
		for(Task t : TaskList.getInstance().getFloatingList()){
			if(t.getTitle().toString().equals("mark")){
				assertFalse(TestUtil.compareTasks(t, ft));
			}
		}
		markFloating.redo();
		for(Task t : TaskList.getInstance().getFloatingList()){
			if(t.getTitle().toString().equals("mark")){
				assertTrue(TestUtil.compareTasks(t, ft));
			}
		}
	}
}

	// End of segment: CEO\src\cs2103\command\MarkTest.java





	/**
	 * origin: CEO\src\cs2103\command\RestoreTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.fusesource.jansi.Ansi.Color.GREEN;
import static org.fusesource.jansi.Ansi.Color.RED;
import static org.junit.Assert.*;


import org.junit.BeforeClass;
import org.junit.Test;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.parameters.ParameterList;
import cs2103.storage.TaskList;
import cs2103.task.FloatingTask;
import cs2103.task.Task;

public class RestoreTest {
	@BeforeClass
	public static void initialise() throws HandledException, FatalException{
		TaskList.getInstance(new Option(Option.Value.TEST)).emptyTestList();;
	}

	@Test
	public void testRestore() throws HandledException, FatalException {
		assert(TaskList.getInstance()!=null);
		Add addObj = new Add("add task to be deleted");
		addObj.execute();
		Delete d = new Delete("1");
		d.execute();
		Restore r = new Restore("1");
		ParameterList pl = r.getParameterList();
		assertEquals(1,pl.getTaskID().getValue());
		String result = r.execute().toString();
		FloatingTask t = TaskList.getInstance().getFloatingList().get(0);
		assertEquals(ansi().fg(GREEN).a("You have successfully restored a task with ID 1\n").reset().a(t.toDetail()).toString(),result);
	}
	
	@Test(expected = HandledException.class)
	public void testTaskNotInTrashRestore() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		Delete d = new Delete("1 -p");
		d.execute();
		Restore r = new Restore("1");
		r.execute().toString();
	}
	
	@Test(expected=HandledException.class)
	public void testInvalidRestore() throws HandledException, FatalException{
		Restore r = new Restore("2");
		r.execute().toString();
	}
	
	@Test
	public void testUndoRedo() throws HandledException, FatalException{
		Add addobj = new Add("add another test");
		addobj.execute();
		Delete d = new Delete("1");
		d.execute();
		Restore r = new Restore("1");
		r.execute();
		r.undo();
		List l = new List("all");
		String result = l.execute().toString();
		assertEquals(ansi().bold().fg(RED).a("The task list is empty\n").reset().toString(),result);
		
		r.redo();
		Task t = TaskList.getInstance().getFloatingList().get(0);
		
		result = l.execute().toString();
		d = new Delete("1 -p");
		d.execute();
		assertEquals(ansi().a(t.toSummary()).a("\n").toString(),result);
	}

}

	// End of segment: CEO\src\cs2103\command\RestoreTest.java





	/**
	 * origin: CEO\src\cs2103\command\Search.java
	 */

package cs2103.command;

import java.util.ArrayList;
import java.util.Date;
import java.util.Map;
import java.util.Queue;

import org.fusesource.jansi.Ansi;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Complete;
import cs2103.parameters.Keyword;
import cs2103.parameters.TaskType;
import cs2103.parameters.Time;
import cs2103.storage.TaskList;
import cs2103.task.Task;
import cs2103.util.CommonUtil;
import cs2103.util.Logger;

public class Search extends QueryCommand {
	private static final String LOG_SEARCH = "Executing Search: Parameters: keyword: %1$s\tTaskType: %2$s\tcompleted: %3$s\ttime: %4$s";
	private static final String TIME_FORMAT = "StartTime: %1$s\tEndTime: %2$s";
	/**
	 * Creates an instance of Search from user input
	 * @param command
	 * @throws HandledException
	 */
	public Search(String command) throws HandledException {
		CommonUtil.checkNull(command, HandledException.ExceptionType.INVALID_CMD);
		Queue<String> parameterQueue = separateCommand(command);
		if (!command.startsWith("-")) {
			this.parameterList.addParameter(Keyword.parse(parameterQueue.poll()));
		}
		Map<String, String> parameterMap = separateParameters(parameterQueue);
		this.parameterList.addParameter(TaskType.parse(getParameterString(parameterMap, TaskType.allowedLiteral)));
		this.parameterList.addParameter(Time.parse(getParameterString(parameterMap, Time.allowedLiteral)));
		this.parameterList.addParameter(Complete.parse(getParameterString(parameterMap, Complete.allowedLiteral)));
	}
	
	@Override
	public Ansi execute() throws HandledException, FatalException {
		Logger.getInstance().writeLog(this.formatLogString());
		ArrayList<Task> searchList = getInitialList(this.parameterList.getTaskType());
		assert(searchList != null);
		if (this.parameterList.getKeyword() != null) {
			searchList = filterKeyword(searchList, parameterList.getKeyword().getValue());
		}
		if (this.parameterList.getTime() != null) {
			searchList = filterTime(searchList, parameterList.getTime().getValue());
		}
		if (this.parameterList.getComplete() != null) {
			searchList = filterComplete(searchList, parameterList.getComplete().getValue());
		}
		return parseListResponse(searchList);
	}
	
	/**
	 * @param taskType
	 * @return ArrayList of Task objects filtered by taskType
	 * @throws HandledException
	 * @throws FatalException
	 */
	private ArrayList<Task> getInitialList(TaskType taskType) throws HandledException, FatalException {
		if (taskType == null) {
			return TaskList.getInstance().getAllList();
		} else {
			switch (taskType.getValue()) {
			case FLOATING:
				return toTaskList(TaskList.getInstance().getFloatingList());
			case DEADLINE:
				return toTaskList(TaskList.getInstance().getDeadlineList());
			case PERIODIC:
				return toTaskList(TaskList.getInstance().getPeriodicList());
			case TRASH:
				return TaskList.getInstance().getTrashList();
			case ALL:
			case INVALID:
			default:
				return TaskList.getInstance().getAllList();
			}
		}
	}
	
	/**
	 * @param tasks
	 * @return ArrayList of Tasks from ArrayList of child classes of Task
	 */
	private static <T extends Task> ArrayList<Task> toTaskList(ArrayList<T> tasks) {
		ArrayList<Task> returnList = new ArrayList<Task>();
		for (Task task:tasks) {
			returnList.add(task);
		}
		return returnList;
	}
	
	/**
	 * @param searchList
	 * @param time
	 * @return ArrayList of tasks that are not floating
	 */
	private static ArrayList<Task> filterTime(ArrayList<Task> searchList, Date[] time) {
		ArrayList<Task> returnList = new ArrayList<Task>();
		if (searchList != null) {
			for (Task task:searchList) {
				if (task.checkPeriod(time)){
					returnList.add(task);
				}
			}
		}
		return returnList;
	}
	
	/**
	 * @param searchList
	 * @param complete
	 * @return ArrayList of Task that are completed
	 */
	private static ArrayList<Task> filterComplete(ArrayList<Task> searchList, boolean complete) {
		ArrayList<Task> returnList = new ArrayList<Task>();
		if (searchList != null) {
			for (Task task:searchList) {
				if ((task.getCompleted() != null) == complete) {
					returnList.add(task);
				}
			}
		}
		return returnList;
	}
	
	/**
	 * @param searchList
	 * @param keywordString
	 * @return ArrayList of Task that contain keywordString
	 */
	private static ArrayList<Task> filterKeyword(ArrayList<Task> searchList, String keywordString) {
		ArrayList<Task> returnList = new ArrayList<Task>();
		if (searchList != null) {
			for (Task task:searchList) {
				if (task.matches(keywordString)) {
					returnList.add(task);
				}
			}
		}
		return returnList;
	}
	
	private String readKeyword() throws HandledException {
		if (this.parameterList.getKeyword() == null) {
			return "null";
		} else {
			return this.parameterList.getKeyword().getValue();
		}
	}
	
	private String readTaskType() throws HandledException {
		if (this.parameterList.getTaskType() == null) {
			return "null";
		} else {
			return this.parameterList.getTaskType().getValue().toString();
		}
	}
	
	private String readComplete() throws HandledException {
		if (this.parameterList.getComplete() == null) {
			return "null";
		} else {
			if(this.parameterList.getComplete().getValue()){
				return "true";
			} else {
				return "false";
			}
		}
	}
	
	private String formatTimeString(Date[] time) {
		assert (time != null);
		return String.format(TIME_FORMAT, this.formatTimeString(time[0]), this.formatTimeString(time[1]));
	}
	
	private String formatTimeString(Date time) {
		if (time == null) {
			return "null";
		} else {
			return time.toString();
		}
	}
	
	private String readTime() throws HandledException {
		if (this.parameterList.getTime() == null) {
			return "null";
		} else {
			return this.formatTimeString(this.parameterList.getTime().getValue());
		}
	}
	
	private String formatLogString() throws HandledException {
		return String.format(LOG_SEARCH, this.readKeyword(), this.readTaskType(), this.readComplete(), this.readTime());
	}
}

	// End of segment: CEO\src\cs2103\command\Search.java





	/**
	 * origin: CEO\src\cs2103\command\SearchTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.fusesource.jansi.Ansi.Color.RED;
import static org.junit.Assert.*;

import org.fusesource.jansi.Ansi;
import org.junit.BeforeClass;
import org.junit.Test;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.storage.TaskList;
import cs2103.task.DeadlineTask;
import cs2103.task.PeriodicTask;
import cs2103.parameters.ParameterList;
import cs2103.parameters.TaskType.Value;

public class SearchTest {
	
	@BeforeClass
	public static void initialise() throws HandledException, FatalException{
		TaskList.getInstance(new Option(Option.Value.TEST)).emptyTestList();;
		Add addObj = new Add("-title Jap homework -time 2014/10/23 21:00");
		addObj.execute();
		addObj = new Add("-title revise stats homework -description revise chp 5 to 7 -location NUS UTOWN -time 2014/10/24 20:00 to 2014/10/25 20:00");
		addObj.execute();
		addObj = new Add("-title celebrate 21st :D -time 2014/11/1 18:00");
		addObj.execute();
		addObj = new Add("-title do cs2105 networking assignment homework");
		addObj.execute();
		addObj = new Add("-title finish essay");
		addObj.execute();
		addObj = new Add("-title complete");
		addObj.execute();
		Mark m = new Mark("6");
		m.execute();
		m = new Mark("3");
		m.execute();
	}
		
	@Test
	public void testSearchKeyword() throws HandledException, FatalException {	
		assert(TaskList.getInstance()!=null);
		Search searchTitle = new Search("homework -time");
		ParameterList pl = searchTitle.getParameterList();
		assertEquals("homework",pl.getKeyword().getValue());
		assertEquals(Value.DEFAULT,pl.getTaskType().getValue());
		String result = searchTitle.execute().toString();
		Ansi deadTaskHw = null;
		for(DeadlineTask t : TaskList.getInstance().getDeadlineList()){
			if(t.getTitle().contains("homework")){
				deadTaskHw = t.toSummary();
			}
		}
		PeriodicTask pt = TaskList.getInstance().getPeriodicList().get(0);
		assertEquals(ansi().a(deadTaskHw).a("\n").a(pt.toSummary()).a("\n").toString(),result);
	}
	
	@Test
	public void testSearchPeriodic() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		Search searchDeadline = new Search("-type deadline -complete");
		ParameterList pl = searchDeadline.getParameterList();
		assertEquals(Value.DEADLINE,pl.getTaskType().getValue());
		String result = searchDeadline.execute().toString();
		Ansi completedDeadline = null;
		for(DeadlineTask t : TaskList.getInstance().getDeadlineList()){
			if(t.getCompleted()!=null){
				completedDeadline = t.toSummary();
			}
		}
		assertEquals(ansi().a(completedDeadline).a("\n").toString(),result);
	}
	
	@Test
	public void testSearchNonExistent() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		Search searchNonExistent = new Search("presentation");
		String result = searchNonExistent.execute().toString();
		assertEquals(ansi().bold().fg(RED).a("The task list is empty\n").reset().toString(),result);
	}
}

	// End of segment: CEO\src\cs2103\command\SearchTest.java





	/**
	 * origin: CEO\src\cs2103\command\Show.java
	 */

package cs2103.command;

import org.fusesource.jansi.Ansi;

import static org.fusesource.jansi.Ansi.*;
import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.TaskID;
import cs2103.storage.TaskList;
import cs2103.task.Task;
import cs2103.util.CommonUtil;
import cs2103.util.Logger;

public class Show extends QueryCommand {
	private static final String MESSAGE_SHOW_FORMAT = "The details for Task %1$d:\n";
	private static final String LOG_SHOW = "Executing Show: Parameters: TaskID: %1$d";
	
	/**
	 * Creates an instance of Show from user input
	 * @param command
	 * @throws HandledException
	 */
	public Show(String command) throws HandledException {
		this.parameterList.addParameter(TaskID.parse(command));
	}
	
	@Override
	public Ansi execute() throws HandledException, FatalException {
		CommonUtil.checkNull(this.parameterList.getTaskID(), HandledException.ExceptionType.INVALID_CMD);
		Logger.getInstance().writeLog(this.formatLogString());
		return formatReturnString(TaskList.getInstance().getTaskByID(parameterList.getTaskID().getValue()));
	}
	
	/**
	 * @param task
	 * @return Ansi formatted string result
	 * @throws HandledException
	 */
	private Ansi formatReturnString(Task task) throws HandledException {
		assert(task != null);
		Ansi returnString = ansi().a(String.format(MESSAGE_SHOW_FORMAT, task.getTaskID()));
		returnString.a(task.toDetail());
		return returnString;
	}
	
	private String formatLogString() throws HandledException {
		assert(this.parameterList.getTaskID() != null);
		return String.format(LOG_SHOW, this.parameterList.getTaskID().getValue());
	}
}

	// End of segment: CEO\src\cs2103\command\Show.java





	/**
	 * origin: CEO\src\cs2103\command\ShowTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.junit.Assert.*;

import org.junit.BeforeClass;
import org.junit.Test;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.storage.TaskList;
import cs2103.task.Task;
import cs2103.parameters.ParameterList;

public class ShowTest {
	@BeforeClass
	public static void initialise() throws HandledException, FatalException{
		TaskList.getInstance(new Option(Option.Value.TEST)).emptyTestList();
		Add addObj = new Add("-title testShow -time 2014/10/23 20:20 to 2014/10/25 10:00 -location home -description much testing, such title");
		addObj.execute();
	}
	
	@Test
	public void testShow() throws HandledException, FatalException {
		Show show = new Show("1");
		ParameterList pl = show.getParameterList();
		assertEquals(1,pl.getTaskID().getValue());
		String result = show.execute().toString();
		Task t = TaskList.getInstance().getPeriodicList().get(0);
		assertEquals(ansi().a("The details for Task 1:\n").a(t.toDetail()).toString(),result);
	}
	
	@Test(expected = HandledException.class)
	public void testInvalidShow() throws HandledException, FatalException{
		Show show = new Show("2");
		show.execute();
	}

}

	// End of segment: CEO\src\cs2103\command\ShowTest.java





	/**
	 * origin: CEO\src\cs2103\command\Sync.java
	 */

package cs2103.command;

import org.fusesource.jansi.Ansi;
import static org.fusesource.jansi.Ansi.*;
import static org.fusesource.jansi.Ansi.Color.*;
import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.storage.TaskList;
import cs2103.util.CommonUtil;

public class Sync extends InfluentialCommand {
	private static final Ansi SUCCESS = ansi().fg(GREEN).a("Successfully sync your data with Google\n").reset();
	private static final Ansi FAILURE = ansi().fg(RED).a("Fail to sync your data with Google\n").reset();
	private static final Ansi DISABLED = ansi().fg(MAGENTA).a("You have disabled sync with Google\n").reset();
	
	/**
	 * Creates an instance of sync from user input
	 * @param command
	 * @throws HandledException
	 */
	public Sync(String command) throws HandledException {
		if (command != null) {
			this.parameterList.addParameter(Option.parse(new String[]{CommonUtil.removeDash(command)}));
		}
	}
	
	@Override
	public InfluentialCommand undo() throws HandledException, FatalException {
		return null;
	}

	@Override
	public InfluentialCommand redo() throws HandledException, FatalException {
		return null;
	}

	@Override
	public Ansi execute() throws HandledException, FatalException {
		if (this.parameterList.getOption() != null && this.parameterList.getOption().getValue().equals(Option.Value.NOSYNC)) {
			TaskList.getInstance().disableSync();
			return DISABLED;
		} else {
			return TaskList.getInstance().manualSync()?SUCCESS:FAILURE;
		}
	}
}

	// End of segment: CEO\src\cs2103\command\Sync.java





	/**
	 * origin: CEO\src\cs2103\command\SyncTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.fusesource.jansi.Ansi.Color.GREEN;
import static org.fusesource.jansi.Ansi.Color.MAGENTA;
import static org.junit.Assert.*;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.storage.TaskList;
import cs2103.task.Task;
import cs2103.util.CommonUtil;

public class SyncTest {

	@BeforeClass
	public static void initialise() throws HandledException, FatalException{
		TaskList.getInstance(new Option(Option.Value.TEST)).emptyTestList();
	}
	
	@Test
	public void testEnableSync() throws HandledException, FatalException {
		assert(CommonUtil.checkSyncSupport());
		for (Task task:TaskList.getInstance().getAllList()){
			TaskList.getInstance().deleteTask(task);
		}
		Sync s = new Sync(null);
		String result = s.execute().toString();
		assertEquals(ansi().fg(GREEN).a("Successfully sync your data with Google\n").reset().toString(),result);
	}
	
	@Test
	public void testDiableSync() throws HandledException, FatalException{
		Sync s = new Sync("-disable");
		String result = s.execute().toString();
		assertEquals(ansi().fg(MAGENTA).a("You have disabled sync with Google\n").reset().toString(),result);
	}
	
	@AfterClass
	public static void cleanUp() throws HandledException, FatalException {
		new Sync("-disable").execute();
	}
}

	// End of segment: CEO\src\cs2103\command\SyncTest.java





	/**
	 * origin: CEO\src\cs2103\command\UpdateTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.junit.Assert.*;

import org.junit.BeforeClass;
import org.junit.Test;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.storage.TaskList;

import cs2103.parameters.ParameterList;
import cs2103.parameters.Recurrence;
import cs2103.parameters.Time;
import cs2103.task.PeriodicTask;
import cs2103.task.Task;
import cs2103.util.TestUtil;

public class UpdateTest {
	
	@BeforeClass
	public static void initialise() throws HandledException, FatalException{
		TaskList.getInstance(new Option(Option.Value.TEST)).emptyTestList();;
		Add addObj = new Add("-title updateTest");
		addObj.execute();
	}

	@Test
	public void testUpdate() throws HandledException, FatalException {
		assert(TaskList.getInstance()!=null);
		Update updateTitle = new Update("1 -title I was wrong -description can't remember -location earth" +
				" -time 2014/12/25 20:20 to 2014/12/31 23:59 -recur 2d");
		
		String time = "2014/12/25 20:20 to 2014/12/31 23:59";
		
		ParameterList pl = updateTitle.getParameterList();
		assertEquals("I was wrong",pl.getTitle().getValue());
		assertEquals("can't remember",pl.getDescription().getValue());
		assertEquals("earth",pl.getLocation().getValue());
		assertEquals(Time.parse(time).getValue()[0].toString(),pl.getTime().getValue()[0].toString());
		assertNotNull(pl.getRecurrence());
		updateTitle.execute();
		
		Task task = new PeriodicTask(null, null, Time.parse(time).getValue()[0], Time.parse(time).getValue()[1]);
		task.updateDescription("can't remember");
		task.updateTitle("I was wrong");
		task.updateLocation("earth");
		task.updateRecurrence(Recurrence.parse("2d").getValue());
		task.updateLastModified(null);
		
		for(Task t : TaskList.getInstance().getPeriodicList()){
			TestUtil.compareTasks(task, t);
		}
	}
	
	@Test(expected = HandledException.class)
	public void testInvalidUpdate() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		Update updateInvalid = new Update("-title this is wrong, so much wrong");
		updateInvalid.execute();
	}
	
	@Test
	public void testUpdateRedoUndo() throws HandledException, FatalException{
		assert(TaskList.getInstance()!=null);
		Add addObj = new Add("-title muchness title -time 2014/11/29 20:20");
		addObj.execute();
		Update updateRedo = new Update("2 -title much wrong, very title");
		updateRedo.execute();
		updateRedo.undo();
		List list = new List("deadline");
		String result = list.execute().toString();
		Task t = TaskList.getInstance().getDeadlineList().get(0);
		assertEquals(ansi().a(t.toSummary()).a("\n").toString(),result);
		updateRedo.redo();
		t = TaskList.getInstance().getDeadlineList().get(0);
		result = list.execute().toString();
		assertEquals(ansi().a(t.toSummary()).a("\n").toString(),result);
	}
}

	// End of segment: CEO\src\cs2103\command\UpdateTest.java





	/**
	 * origin: CEO\src\cs2103\command\UpdateTimeFromRecur.java
	 */

package cs2103.command;

import java.util.ArrayList;

import org.fusesource.jansi.Ansi;

import static org.fusesource.jansi.Ansi.*;
import static org.fusesource.jansi.Ansi.Color.*;
import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.storage.TaskList;
import cs2103.task.PeriodicTask;
import cs2103.task.Task;

public class UpdateTimeFromRecur extends InfluentialCommand {
	private static final String MESSAGE_UPDATE_RECUR_TIME_FORMAT = "Successfully updated %1$d recurring tasks\n";
	
	@Override
	public Ansi execute() throws HandledException, FatalException {
		int count = 0;
		ArrayList<PeriodicTask> periodicList = TaskList.getInstance().getPeriodicList();
		for (PeriodicTask task:periodicList) {
			Task newTask = task.updateTimeFromRecur();
			if (newTask != null) {
				count++;
				TaskList.getInstance().updateTask(newTask);
			}
		}
		return ansi().fg(GREEN).a(String.format(MESSAGE_UPDATE_RECUR_TIME_FORMAT, count)).reset();
	}

	@Override
	public InfluentialCommand undo() {
		//not required for this type of command
		return null;
	}

	@Override
	public InfluentialCommand redo() {
		//not required for this type of command
		return null;
	}

}

	// End of segment: CEO\src\cs2103\command\UpdateTimeFromRecur.java





	/**
	 * origin: CEO\src\cs2103\command\UpdateTimeFromRecurTest.java
	 */

package cs2103.command;

import static org.fusesource.jansi.Ansi.ansi;
import static org.fusesource.jansi.Ansi.Color.GREEN;
import static org.junit.Assert.*;

import org.junit.BeforeClass;
import org.junit.Test;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Option;
import cs2103.storage.TaskList;

public class UpdateTimeFromRecurTest {

	@BeforeClass
	public static void initialise() throws HandledException, FatalException{
		TaskList.getInstance(new Option(Option.Value.TEST)).emptyTestList();;
		Add addObj = new Add("-title updateFromRecur -time 2014/10/18 23:00 to 2014/10/20 23:00 -recur 2d");
		addObj.execute();
	}
	
	@Test
	public void testUpdateFromRecur() throws HandledException, FatalException {
		
		UpdateTimeFromRecur ufr = new UpdateTimeFromRecur();
		String result = ufr.execute().toString();
		assertEquals(ansi().fg(GREEN).a("Successfully updated 1 recurring tasks\n").reset().toString(),result);
		
	}

}

	// End of segment: CEO\src\cs2103\command\UpdateTimeFromRecurTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\CommandType.java
	 */

package cs2103.parameters;

public class CommandType implements Parameter {
	public static final String type = "COMMANDTYPE";
	private final Value value;
	
	public static enum Value {
		ADD, LIST, SHOW, DELETE, UPDATE, EXIT, UNDO, REDO, HELP, SEARCH, QUICK, ALERT, MARK, RESTORE, SYNC, INVALID;
	}
	
	/**
	 * @param value
	 */
	public CommandType(Value value) {
		this.value = value;
	}
	
	/**
	 * @return Value enumerator of CommandType
	 */
	public Value getValue() {
		return this.value;
	}
	
	@Override
	public String getType() {
		return type;
	}
	
	/**
	 * @param commandTypeString
	 * @return CommandType object of String commandTypeString
	 */
	public static CommandType parse(String commandTypeString) {
		return new CommandType(parseTaskType(commandTypeString));
	}
	
	/**
	 * @param commandTypeString
	 * @return Value enumerator of String commandTypeString
	 */
	private static Value parseTaskType(String commandTypeString) {
		if (commandTypeString == null) {
			return Value.INVALID;
		}
		if (commandTypeString.equalsIgnoreCase("list")) {
			return Value.LIST;
		} else if (commandTypeString.equalsIgnoreCase("update") || commandTypeString.equalsIgnoreCase("modify")) {
			return Value.UPDATE;
		} else if (commandTypeString.equalsIgnoreCase("exit") || commandTypeString.equalsIgnoreCase("bye")) {
			return Value.EXIT;
		} else if (commandTypeString.equalsIgnoreCase("add") || commandTypeString.equalsIgnoreCase("new") || commandTypeString.equalsIgnoreCase("create")) {
			return Value.ADD;
		} else if (commandTypeString.equalsIgnoreCase("delete") || commandTypeString.equalsIgnoreCase("remove") || commandTypeString.equalsIgnoreCase("del")) {
			return Value.DELETE;
		} else if (commandTypeString.equalsIgnoreCase("show") || commandTypeString.equalsIgnoreCase("detail")) {
			return Value.SHOW;
		} else if (commandTypeString.equalsIgnoreCase("undo")) {
			return Value.UNDO;
		} else if (commandTypeString.equalsIgnoreCase("redo")) {
			return Value.REDO;
		} else if (commandTypeString.equalsIgnoreCase("help")) {
			return Value.HELP;
		} else if (commandTypeString.equalsIgnoreCase("search") || commandTypeString.equalsIgnoreCase("find")) {
			return Value.SEARCH;
		} else if (commandTypeString.equalsIgnoreCase("mark") || commandTypeString.equalsIgnoreCase("complete") || commandTypeString.equalsIgnoreCase("finish")) {
			return Value.MARK;
		} else if (commandTypeString.equalsIgnoreCase("alert") || commandTypeString.equalsIgnoreCase("remind")) {
			return Value.ALERT;
		} else if (commandTypeString.equalsIgnoreCase("recover") || commandTypeString.equalsIgnoreCase("restore")) {
			return Value.RESTORE;
		} else if (commandTypeString.equalsIgnoreCase("google") || commandTypeString.equalsIgnoreCase("sync")) {
			return Value.SYNC;
		} else {
			return Value.INVALID;
		}
	}

}

	// End of segment: CEO\src\cs2103\parameters\CommandType.java





	/**
	 * origin: CEO\src\cs2103\parameters\CommandTypeTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import org.junit.Test;

import cs2103.parameters.CommandType.Value;

public class CommandTypeTest {

	@Test
	public void testCommandType() {
		CommandType ct = new CommandType(Value.ALERT);
		assertEquals(Value.ALERT,ct.getValue());
		
		ct = CommandType.parse("UPDATE");
		assertEquals(Value.UPDATE,ct.getValue());
		
		ct = CommandType.parse("hello");
		assertEquals(Value.INVALID,ct.getValue());
		
		ct = CommandType.parse(null);
		assertEquals(Value.INVALID,ct.getValue());

	}

}

	// End of segment: CEO\src\cs2103\parameters\CommandTypeTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\Complete.java
	 */

package cs2103.parameters;

import cs2103.exception.HandledException;

public class Complete implements Parameter {
	public static final String type = "COMPLETE";
	public static final String[] allowedLiteral = {"C", "complete", "status"};
	private final boolean complete;
	
	/**
	 * @param complete
	 */
	public Complete(boolean complete) {
		this.complete = complete;
	}
	
	/**
	 * @return boolean value of Complete object
	 */
	public boolean getValue() {
		return this.complete;
	}
	
	@Override
	public String getType() {
		return type;
	}
	
	/**
	 * @param completeString
	 * @return Complete object for String completeString, or null if completeString is null
	 * @throws HandledException
	 */
	public static Complete parse(String completeString) throws HandledException {
		if (completeString == null) {
			return null;
		} else {
			return new Complete(parseComplete(completeString));
		}
	}
	
	/**
	 * @param complete
	 * @return boolean value of String complete
	 * @throws HandledException
	 */
	private static boolean parseComplete(String complete) throws HandledException {
		if (complete.equals("")) {
			return true;
		} else if (complete.equalsIgnoreCase("true")) {
			return true;
		} else if (complete.equalsIgnoreCase("false")) {
			return false;
		} else {
			throw new HandledException(HandledException.ExceptionType.INVALID_COMPLETE);
		}
	}
}

	// End of segment: CEO\src\cs2103\parameters\Complete.java





	/**
	 * origin: CEO\src\cs2103\parameters\CompleteTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import org.junit.Test;

import cs2103.exception.HandledException;

public class CompleteTest {

	@Test
	public void testComplete() throws HandledException {
		Complete c = new Complete(false);
		assertFalse(c.getValue());
		c = Complete.parse("true");
		assertTrue(c.getValue());
		
		c = Complete.parse("");
		assertTrue(c.getValue());
	}
	
	@SuppressWarnings("unused")
	@Test (expected = HandledException.class)
	public void testInvalidString() throws HandledException {
		Complete check = Complete.parse("hello");
	}
	

}

	// End of segment: CEO\src\cs2103\parameters\CompleteTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\DeleteOption.java
	 */

package cs2103.parameters;

public class DeleteOption implements Parameter {
	public static final String type = "DELETEOPTION";
	public static final String[] allowedLiteral = {"P", "p", "permanent", "forever"};
	private final boolean permanent;
	
	/**
	 * @param permanent
	 */
	public DeleteOption(boolean permanent) {
		this.permanent = permanent;
	}
	
	/**
	 * @return boolean value for permanent
	 */
	public boolean getValue() {
		return this.permanent;
	}
	
	/**
	 * @param permanent
	 * @return DeleteOption object, or null if permanent is null
	 */
	public static DeleteOption parse(String permanent) {
		if (permanent == null) {
			return null;
		} else {
			return new DeleteOption(true);
		}
		
	}
	
	@Override
	public String getType() {
		return type;
	}

}

	// End of segment: CEO\src\cs2103\parameters\DeleteOption.java





	/**
	 * origin: CEO\src\cs2103\parameters\DeleteOptionTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import org.junit.Test;

public class DeleteOptionTest {

	@Test
	public void testDelete() {
		DeleteOption dOption = DeleteOption.parse("");
		assertTrue(dOption.getValue());
		
		dOption = DeleteOption.parse(null);
		assertNull(dOption);
		
	}

}

	// End of segment: CEO\src\cs2103\parameters\DeleteOptionTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\Description.java
	 */

package cs2103.parameters;

public class Description implements Parameter {
	public static final String[] allowedLiteral = {"D", "description", "detail"};
	public static final String type = "DESCRIPTION";
	private final String description;
	
	/**
	 * @param description
	 */
	public Description(String description) {
		this.description = description;
	}
	
	/**
	 * @return String description of Description
	 */
	public String getValue() {
		return this.description;
	}
	
	@Override
	public String getType() {
		return type;
	}
	
	/**
	 * @param description
	 * @return Description object of string description, or null if description is null
	 */
	public static Description parse(String description) {
		if (description == null) {
			return null;
		} else {
			return new Description(description);
		}
	}
}

	// End of segment: CEO\src\cs2103\parameters\Description.java





	/**
	 * origin: CEO\src\cs2103\parameters\DescriptionTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import org.junit.Test;

public class DescriptionTest {

	@Test
	public void testDescription() {
		Description d = Description.parse("this is another desc");
		assertEquals("this is another desc",d.getValue());
		assertEquals("DESCRIPTION",d.getType());
		
		d = Description.parse(null);
		assertNull(d);
		
	}

}

	// End of segment: CEO\src\cs2103\parameters\DescriptionTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\Keyword.java
	 */

package cs2103.parameters;

public class Keyword implements Parameter {
	public static final String type = "KEYWORD";
	private final String keyword;
	
	/**
	 * @param keyword
	 */
	public Keyword(String keyword) {
		this.keyword = keyword;
	}
	
	/**
	 * @return String value of Keyword keyword
	 */
	public String getValue() {
		return this.keyword;
	}
	
	@Override
	public String getType() {
		return type;
	}
	
	/**
	 * @param keyword
	 * @return Keyword object of string keyword, or null if keyword is null
	 */
	public static Keyword parse(String keyword) {
		if (keyword == null) {
			return null;
		} else {
			return new Keyword(keyword);
		}
	}
}

	// End of segment: CEO\src\cs2103\parameters\Keyword.java





	/**
	 * origin: CEO\src\cs2103\parameters\KeywordTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import org.junit.Test;

public class KeywordTest {

	@Test
	public void testKeyword() {
		Keyword kw = Keyword.parse("Utown");
		assertEquals("Utown", kw.getValue());
		assertEquals("KEYWORD",kw.getType());
		
		kw = Keyword.parse(null);
		assertNull(kw);
	}

}

	// End of segment: CEO\src\cs2103\parameters\KeywordTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\Location.java
	 */

package cs2103.parameters;

public class Location implements Parameter {
	public static final String[] allowedLiteral = {"L", "location", "place"};
	public static final String type = "LOCATION";
	private final String location;
	
	public Location(String location) {
		this.location = location;
	}
	
	public String getValue() {
		return this.location;
	}
	
	@Override
	public String getType() {
		return type;
	}
	
	/**
	 * @param location
	 * @return Location option from String location, or null if location is null
	 */
	public static Location parse(String location) {
		if (location == null) {
			return null;
		} else {
			return new Location(location);
		}
	}
}

	// End of segment: CEO\src\cs2103\parameters\Location.java





	/**
	 * origin: CEO\src\cs2103\parameters\LocationTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import org.junit.Test;

public class LocationTest {

	@Test
	public void testLocation() {
		Location loc = Location.parse("Hougang,Singapore");
		assertEquals("Hougang,Singapore",loc.getValue());
		assertEquals("LOCATION",loc.getType());
		
	}

}

	// End of segment: CEO\src\cs2103\parameters\LocationTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\Option.java
	 */

package cs2103.parameters;

import cs2103.exception.HandledException;
import cs2103.util.CommonUtil;

public class Option implements Parameter {
	public static final String type = "OPTION";
	public static enum Value {
		DEFAULT, NOSYNC, TEST, SYNC;
	}
	private final Value value;
	
	/**
	 * @param value
	 */
	public Option(Value value) {
		this.value = value;
	}
	
	@Override
	public String getType() {
		return type;
	}
	
	/**
	 * @return Value enumerator for Option
	 */
	public Value getValue() {
		return this.value;
	}
	
	/**
	 * @param optionString
	 * @return Option object from String array optionString
	 * @throws HandledException
	 */
	public static Option parse(String[] optionString) throws HandledException {
		return new Option(parseOption(optionString));
	}
	
	/**
	 * @param optionString
	 * @return Value enumerator that matches the String option in 1st index of String array optionString
	 * @throws HandledException
	 */
	private static Value parseOption(String[] optionString) throws HandledException {
		if (optionString == null || optionString.length < 1) {
			return Value.DEFAULT;
		} else {
			String option = CommonUtil.removeDash(optionString[0]);
			if (option.equalsIgnoreCase("nosync") || option.equalsIgnoreCase("no-sync") || option.equalsIgnoreCase("disable-sync") || option.equalsIgnoreCase("disable")) {
				return Value.NOSYNC;
			} else if (option.equalsIgnoreCase("test")) {
				return Value.TEST;
			} else if (option.equalsIgnoreCase("sync") || option.equalsIgnoreCase("enable-sync") || option.equalsIgnoreCase("enable")) {
				return Value.SYNC;
			} else {
				return Value.DEFAULT;
			}
		}
	}
}

	// End of segment: CEO\src\cs2103\parameters\Option.java





	/**
	 * origin: CEO\src\cs2103\parameters\OptionTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import org.junit.Test;

import cs2103.exception.HandledException;
import cs2103.parameters.Option.Value;

public class OptionTest {

	@Test
	public void testOption() throws HandledException {
		String param = "-test";
		Option opt = Option.parse(param.split(" "));
		assertEquals(Value.TEST,opt.getValue());
	}
}

	// End of segment: CEO\src\cs2103\parameters\OptionTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\ParameterListTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Test;

import cs2103.exception.HandledException;

public class ParameterListTest {

	/**
	 * Test adding and retrieving of parameters in ParameterList
	 * @throws HandledException
	 */
	@Test
	public void testParameter() throws HandledException {
		ParameterList pl = new ParameterList();
		pl.addParameter(Title.parse("title"));
		pl.addParameter(Location.parse("location"));
		pl.addParameter(Description.parse("desc"));
		pl.addParameter(TaskID.parse("1"));
		pl.addParameter(Keyword.parse("nus"));
		pl.addParameter(Complete.parse("false"));
		
		ArrayList<Parameter> pArrayList = new ArrayList<Parameter>();
		
		pArrayList.add(Time.parse("2014/10/29 20:20"));
		pArrayList.add(TaskType.parse("Deadline"));
		pArrayList.add(Recurrence.parse("2d"));
		
		pl.addAllParameters(pArrayList);
		
		assertEquals(9,pl.getParameterCount());
		assertEquals(Title.parse("title").getValue(),pl.getTitle().getValue());
		assertEquals(Location.parse("location").getValue(),pl.getLocation().getValue());
		assertEquals(TaskID.parse("1").getValue(),pl.getTaskID().getValue());
		assertEquals(Keyword.parse("nus").getValue(),pl.getKeyword().getValue());
		assertEquals(Complete.parse("false").getValue(),pl.getComplete().getValue());
		assertEquals(Time.parse("2014/10/29 20:20").getValue()[0].toString(),pl.getTime().getValue()[0].toString());
		assertEquals(TaskType.parse("Deadline").getValue(),pl.getTaskType().getValue());
		assertEquals(Recurrence.parse("2d").getValue().toString(),pl.getRecurrence().getValue().toString());
	}

}

	// End of segment: CEO\src\cs2103\parameters\ParameterListTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\RecurrenceTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import java.text.ParseException;

import org.junit.Test;

import cs2103.exception.HandledException;

public class RecurrenceTest {

	@Test
	public void testRecurrence() throws HandledException, ParseException {
		Recurrence rec = Recurrence.parse("2d");
		assertEquals("RECURRENCE",rec.getType());
		assertEquals("FREQ=DAILY;INTERVAL=2",rec.getValue().toString());
		
		rec = Recurrence.parse("abc");
		assertNull(rec.getValue());
		
		rec = Recurrence.parse(null);
		assertNull(rec);
	}

}

	// End of segment: CEO\src\cs2103\parameters\RecurrenceTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\TaskID.java
	 */

package cs2103.parameters;

import cs2103.exception.HandledException;
import cs2103.util.CommonUtil;

public class TaskID implements Parameter {
	public static final String type = "TASKID";
	private final int taskID;
	
	public TaskID(int taskID){
		this.taskID = taskID;
	}
	
	/**
	 * @return int value of taskID
	 */
	public int getValue() {
		return this.taskID;
	}
	
	@Override
	public String getType() {
		return type;
	}
	
	/**
	 * @param taskIDString
	 * @return TaskID object from String taskIDString, or null if taskIDString is null
	 * @throws HandledException
	 */
	public static TaskID parse(String taskIDString) throws HandledException {
		if (taskIDString == null) {
			return null;
		} else {
			return new TaskID(CommonUtil.parseIntegerParameter(taskIDString));
		}
	}
}

	// End of segment: CEO\src\cs2103\parameters\TaskID.java





	/**
	 * origin: CEO\src\cs2103\parameters\TaskIDTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import org.junit.Test;

import cs2103.exception.HandledException;

public class TaskIDTest {

	@Test
	public void test() throws HandledException {
		TaskID tid = TaskID.parse("1");
		assertEquals(1,tid.getValue());
		
		tid = TaskID.parse(null);
		assertNull(tid);
	}

}

	// End of segment: CEO\src\cs2103\parameters\TaskIDTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\TaskType.java
	 */

package cs2103.parameters;

public class TaskType implements Parameter {
	public static final String[] allowedLiteral = {"K", "type", "kind", "tasktype"};
	public static final String type = "TASKTYPE";
	private final Value value;
	
	public static enum Value {
		ALL, FLOATING, DEADLINE, PERIODIC, DEFAULT, TRASH, INVALID;
	}
	
	public TaskType(Value value) {
		this.value = value;
	}
	
	public Value getValue() {
		return this.value;
	}
	
	@Override
	public String getType() {
		return type;
	}
	
	/**
	 * @param taskTypeString
	 * @return TaskType object from String taskTypeString
	 */
	public static TaskType parse(String taskTypeString) {
		return new TaskType(parseTaskType(taskTypeString));
	}
	
	/**
	 * @param taskTypeString
	 * @return Value enumerator of taskTypeString
	 */
	private static Value parseTaskType(String taskTypeString) {
		if (taskTypeString == null || taskTypeString.isEmpty()) {
			return Value.DEFAULT;
		}
		if (taskTypeString.equalsIgnoreCase("all")) {
			return Value.ALL;
		} else if (taskTypeString.equalsIgnoreCase("floating")) {
			return Value.FLOATING;
		} else if (taskTypeString.equalsIgnoreCase("deadline")) {
			return Value.DEADLINE;
		} else if (taskTypeString.equalsIgnoreCase("periodic")) {
			return Value.PERIODIC;
		} else if (taskTypeString.equalsIgnoreCase("trash")) {
			return Value.TRASH;
		} else {
			return Value.INVALID;
		}
	}
}

	// End of segment: CEO\src\cs2103\parameters\TaskType.java





	/**
	 * origin: CEO\src\cs2103\parameters\TaskTypeTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import org.junit.Test;

import cs2103.parameters.TaskType.Value;

public class TaskTypeTest {

	@Test
	public void testTaskType() {
		TaskType taskType = TaskType.parse("deadline");
		assertEquals(Value.DEADLINE,taskType.getValue());
		
		taskType = TaskType.parse(null);
		assertEquals(Value.DEFAULT,taskType.getValue());
	}

}

	// End of segment: CEO\src\cs2103\parameters\TaskTypeTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\TimeTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import java.util.Calendar;
import java.util.Date;

import org.junit.Test;

public class TimeTest {

	@Test
	public void testValidTime() {
		Time t = Time.parse("2014/10/29 20:20");
		Date[] date = t.getValue();
		Calendar c = Calendar.getInstance();
		c.set(2014, 9, 29, 20,20,00);
		Date d = c.getTime();
		assertEquals(d.toString(),date[0].toString());
	}
	
	@Test
	public void testInvalidTime(){
		Time t = Time.parse("hi");
		Date[] date = t.getValue();
		assertNull(date[0]);
		
		t = Time.parse(null);
		assertNull(t);
	}

}

	// End of segment: CEO\src\cs2103\parameters\TimeTest.java





	/**
	 * origin: CEO\src\cs2103\parameters\Title.java
	 */

package cs2103.parameters;

public class Title implements Parameter {
	public static final String[] allowedLiteral = {"S", "title", "summary"};
	public static final String type = "TITLE";
	private final String title;
	
	/**
	 * @param title
	 */
	public Title(String title) {
		this.title = title;
	}
	
	/**
	 * @return String value of Title
	 */
	public String getValue() {
		return this.title;
	}
	
	@Override
	public String getType() {
		return type;
	}
	
	/**
	 * @param titleString
	 * @return Title object from String titleString, or null if titleString is null
	 */
	public static Title parse(String titleString) {
		if (titleString == null) {
			return null;
		} else {
			return new Title(titleString);
		}
	}
}

	// End of segment: CEO\src\cs2103\parameters\Title.java





	/**
	 * origin: CEO\src\cs2103\parameters\TitleTest.java
	 */

package cs2103.parameters;

import static org.junit.Assert.*;

import org.junit.Test;

public class TitleTest {

	@Test
	public void testTitle() {
		Title t = Title.parse("this is some title");
		assertEquals("this is some title",t.getValue());
		
		t = Title.parse(null);
		assertNull(t);
	}

}

	// End of segment: CEO\src\cs2103\parameters\TitleTest.java






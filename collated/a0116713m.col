//@author: a0116713m



	/**
	 * origin: CEO\src\cs2103\command\Add.java
	 */

package cs2103.command;

import java.util.ArrayList;
import java.util.Date;
import java.util.Map;
import java.util.Queue;

import org.fusesource.jansi.Ansi;

import static org.fusesource.jansi.Ansi.*;
import static org.fusesource.jansi.Ansi.Color.*;
import net.fortuna.ical4j.model.Recur;
import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Description;
import cs2103.parameters.Location;
import cs2103.parameters.Parameter;
import cs2103.parameters.Recurrence;
import cs2103.parameters.Time;
import cs2103.parameters.Title;
import cs2103.storage.TaskList;
import cs2103.task.*;
import cs2103.util.CommonUtil;
import cs2103.util.Logger;

public class Add extends InfluentialCommand {
	private static final String MESSAGE_ADD = "You have successfully added a new task.\n";
	private static final String MESSAGE_ADD_FAIL = "Fail to add a new task.\n";
	private static final String[] allowedQuickTimeLiteral = {"from", "by", "on", "in", "at"};
	private static final String LOG_ADD = "Executing Add: Parameters: title: %1$s\tdescription %2$s\tlocation: %3$s\ttime: %4$s";
	private static final String TIME_FORMAT = "StartTime: %1$s\tEndTime: %2$s";
	
	/**
	 * Creates an instance of Add using the string that the user entered
	 * @param command
	 * @throws HandledException
	 */
	public Add(String command) throws HandledException {
		CommonUtil.checkNull(command, HandledException.ExceptionType.INVALID_CMD);
		Queue<String> parameterQueue = separateCommand(command);
		if (!command.startsWith("-")) {
			this.parameterList.addAllParameters(parseQuickAdd(parameterQueue.poll()));
		}
		Map<String, String> parameterMap = separateParameters(parameterQueue);
		this.parameterList.addParameter(Title.parse(getParameterString(parameterMap, Title.allowedLiteral)));
		this.parameterList.addParameter(Description.parse(getParameterString(parameterMap, Description.allowedLiteral)));
		this.parameterList.addParameter(Time.parse(getParameterString(parameterMap, Time.allowedLiteral)));
		this.parameterList.addParameter(Location.parse(getParameterString(parameterMap, Location.allowedLiteral)));
		this.parameterList.addParameter(Recurrence.parse(getParameterString(parameterMap, Recurrence.allowedLiteral)));
	}
	
	@Override
	public Ansi execute() throws HandledException, FatalException {
		Task task;
		Date[] time = getTime(this.parameterList.getTime());
		assert(time != null);
		Logger.getInstance().writeLog(this.formatLogString(time));
		if (time[0] == null) {
			task = new FloatingTask(null, null);
		} else if (time[1] == null) {
			task = new DeadlineTask(null, null, time[0]);
		} else {
			task = new PeriodicTask(null, null, time[0], time[1]);
		}
		task.updateTitle(this.readTitle());
		task.updateDescription(this.readDescription());
		task.updateLocation(this.readLocation());
		task.updateRecurrence(this.readRecurrence());
		task.updateLastModified(null);
		task = TaskList.getInstance().addTask(task);
		return this.formatReturnString(task);
	}
	
	/**
	 * Extracts parameters and respective values from quick add strings
	 * @param quickAddString
	 * @return ArrayList of Parameter object from user input (quickAddString)
	 * @throws HandledException
	 */
	private static ArrayList<Parameter> parseQuickAdd(String quickAddString) throws HandledException {
		int timeIndex = -1;
		for (String s:allowedQuickTimeLiteral) {
			timeIndex = quickAddString.lastIndexOf(s);
			if (timeIndex > 0) break;
		}
		int everyIndex = quickAddString.lastIndexOf("every");
		if (timeIndex < 0) {
			return getQuickAddParameters(quickAddString);
		} else if (everyIndex > timeIndex) {
			return getQuickAddParameters(quickAddString, timeIndex, everyIndex);
		} else {
			return getQuickAddParameters(quickAddString, timeIndex);
		}
	}
	
	private static ArrayList<Parameter> getQuickAddParameters(String quickAddString) {
		ArrayList<Parameter> parameterList = new ArrayList<Parameter>();
		parameterList.add(Title.parse(quickAddString));
		return parameterList;
	}
	
	private static ArrayList<Parameter> getQuickAddParameters(String quickAddString, int timeIndex) {
		Time time = parseQuickTime(quickAddString.substring(timeIndex));
		if (time == null) {
			return getQuickAddParameters(quickAddString);
		} else {
			ArrayList<Parameter> returnList = new ArrayList<Parameter>();
			returnList.add(Title.parse(quickAddString.substring(0, timeIndex)));
			returnList.add(time);
			return returnList;
		}
	}
	
	private static ArrayList<Parameter> getQuickAddParameters(String quickAddString, int timeIndex, int everyIndex) throws HandledException {
		Time time = parseQuickTime(quickAddString.substring(timeIndex, everyIndex));
		if (time == null) {
			return getQuickAddParameters(quickAddString);
		} else {
			ArrayList<Parameter> returnList = new ArrayList<Parameter>();
			returnList.add(Title.parse(quickAddString.substring(0, timeIndex)));
			returnList.add(time);
			returnList.add(Recurrence.parse(quickAddString.substring(everyIndex)));
			return returnList;
		}
	}
	
	/**
	 * @param timeString
	 * @return Time object from String timeString
	 */
	private static Time parseQuickTime(String timeString) {
		Time time = Time.parse(timeString);
		Date[] timeArray = getTime(time);
		if (timeArray[0] == null && timeArray[1] == null) {
			return null;
		} else {
			return time;
		}
	}
	
	/**
	 * @param timeParameter
	 * @return Date array from Time timeParameter
	 */
	private static Date[] getTime(Time timeParameter) {
		if (timeParameter == null) {
			return new Date[2];
		} else {
			return timeParameter.getValue();
		}
	}
	
	/**
	 * @param task
	 * @return Ansi formatted String for Add object
	 */
	private Ansi formatReturnString(Task task) {
		if (task == null) {
			return ansi().bold().fg(RED).a(MESSAGE_ADD_FAIL).reset();
		} else {
			this.undoBackup = task;
			this.redoBackup = task;
			return ansi().fg(GREEN).a(MESSAGE_ADD).a(task.toDetail());
		}
	}
	
	/**
	 * @return String value of title that is entered by user
	 * @throws HandledException
	 */
	private String readTitle() throws HandledException {
		if (this.parameterList.getTitle() == null) {
			throw new HandledException(HandledException.ExceptionType.NO_TITLE);
		} else {
			return this.parameterList.getTitle().getValue();
		}
	}
	
	/**
	 * @return String value of description that is entered by user
	 * @throws HandledException
	 */
	private String readDescription() throws HandledException {
		if (this.parameterList.getDescription() == null) {
			return null;
		} else {
			return this.parameterList.getDescription().getValue();
		}
	}
	
	/**
	 * @return String value of location that is entered by user
	 * @throws HandledException
	 */
	private String readLocation() throws HandledException {
		if (this.parameterList.getLocation() == null) {
			return null;
		} else {
			return this.parameterList.getLocation().getValue();
		}
	}
	
	/**
	 * @return Recur object from recurrence string entered by user
	 * @throws HandledException
	 */
	private Recur readRecurrence() throws HandledException {
		if (this.parameterList.getRecurrence() == null) {
			return null;
		} else {
			return this.parameterList.getRecurrence().getValue();
		}
	}
	
	private String formatTimeString(Date[] time) {
		assert (time != null);
		return String.format(TIME_FORMAT, this.formatTimeString(time[0]), this.formatTimeString(time[1]));
	}
	
	private String formatTimeString(Date time) {
		if (time == null) {
			return "null";
		} else {
			return time.toString();
		}
	}
	
	private String formatLogString(Date[] time) throws HandledException {
		assert(time != null);
		return String.format(LOG_ADD, this.readTitle(), this.readDescription(), this.readLocation(), this.formatTimeString(time));
	}
	
	@Override
	public InfluentialCommand undo() throws HandledException, FatalException {
		if (this.undoBackup == null) {
			return null;
		} else {
			this.undoBackup.updateLastModified(null);
			TaskList.getInstance().deleteTask(this.undoBackup);
			return this;
		}
	}

	@Override
	public InfluentialCommand redo() throws HandledException, FatalException {
		if (this.redoBackup == null) {
			return null;
		} else {
			this.redoBackup.updateLastModified(null);
			TaskList.getInstance().addTask(this.redoBackup);
			return this;
		}
	}
}

	// End of segment: CEO\src\cs2103\command\Add.java





	/**
	 * origin: CEO\src\cs2103\command\Command.java
	 */

package cs2103.command;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;

import org.fusesource.jansi.Ansi;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.ParameterList;
import cs2103.util.CommonUtil;

public abstract class Command {
	protected ParameterList parameterList = new ParameterList();
	/**
	 * @return Result Ansi to be printed
	 * @throws HandledException
	 * @throws FatalException
	 */
	public abstract Ansi execute() throws HandledException, FatalException;
	
	/**
	 * @param userInput
	 * @return Parameters and values in form of Queue<String>
	 * @throws HandledException
	 */
	protected static Queue<String> separateCommand(String userInput) throws HandledException {
		CommonUtil.checkNull(userInput, HandledException.ExceptionType.INVALID_CMD);
		Queue<String> result = new LinkedList<String>();
		String[] parameters = userInput.trim().split("\\s+-");
		for (String s:parameters) {
			result.add(CommonUtil.removeDash(s.trim()));
		}
		return result;
	}
	
	/**
	 * @param parameterList
	 * @return Map<String,String> of parameters and values
	 * @throws HandledException
	 */
	protected static Map<String,String> separateParameters(Queue<String> parameterList) throws HandledException {
		CommonUtil.checkNull(parameterList, HandledException.ExceptionType.INVALID_PARA);
		Map<String,String> parameterMap = new HashMap<String, String>();
		while(!parameterList.isEmpty()) {
			String[] splitResult = CommonUtil.splitFirstWord(parameterList.poll());
			if (splitResult[0] != null) {
				parameterMap.put(splitResult[0], splitResult[1]);
			}
		}
		return parameterMap;
	}
	
	
	/**
	 * @param parameterMap
	 * @param allowedLiteral
	 * @return String value for respective parameters
	 */
	protected static String getParameterString(Map<String, String> parameterMap, String[] allowedLiteral) {
		for (String s:allowedLiteral) {
			String result = getParameterFromMap(parameterMap, s);
			if (result != null) return result;
		}
		return null;
	}
	
	private static String getParameterFromMap(Map<String, String> parameterMap, String parameterType) {
		if (parameterMap.containsKey(parameterType)) {
			String value=parameterMap.get(parameterType);
			if (value == null) {
				return "";
			}else{
				return value;
			}
		}else{
			return null;
		}
	}
	
	public ParameterList getParameterList() {
		return this.parameterList;
	}
}

	// End of segment: CEO\src\cs2103\command\Command.java





	/**
	 * origin: CEO\src\cs2103\command\Delete.java
	 */

package cs2103.command;

import java.util.Map;
import java.util.Queue;

import org.fusesource.jansi.Ansi;

import static org.fusesource.jansi.Ansi.*;
import static org.fusesource.jansi.Ansi.Color.*;
import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.DeleteOption;
import cs2103.parameters.TaskID;
import cs2103.storage.TaskList;
import cs2103.task.Task;
import cs2103.util.CommonUtil;
import cs2103.util.Logger;

public class Delete extends InfluentialCommand {
	private static final String MESSAGE_DELETE = "You have moved task with ID %1$d to trash\n";
	private static final String MESSAGE_PERMANENTLY_DELETE = "You have permanently deleted task with ID %1$d\n";
	private Task target;	
	private static final String LOG_DELETE = "Executing Delete: Parameters: TaskID: %1$d\tPermanent: %2$s";
	
	/**
	 * Creates an instance of Delete from user input command
	 * @param command
	 * @throws HandledException
	 * @throws FatalException
	 */
	public Delete(String command) throws HandledException, FatalException {
		CommonUtil.checkNull(command, HandledException.ExceptionType.INVALID_CMD);
		Queue<String> parameterQueue = separateCommand(command);
		this.parameterList.addParameter(TaskID.parse(parameterQueue.poll()));
		Map<String, String> parameterMap = separateParameters(parameterQueue);
		this.parameterList.addParameter(DeleteOption.parse(getParameterString(parameterMap, DeleteOption.allowedLiteral)));
		CommonUtil.checkNull(this.parameterList.getTaskID(), HandledException.ExceptionType.INVALID_CMD);
		this.target = TaskList.getInstance().getTaskByID(this.parameterList.getTaskID().getValue());

	}
	
	@Override
	public Ansi execute() throws HandledException, FatalException {
		assert (this.target != null);
		Logger.getInstance().writeLog(this.formatLogString());
		Task deleting = cloneTask(this.target);
		this.undoBackup = this.target;
		if (this.parameterList.getDeleteOption() == null && !this.target.isDeleted()) {
			deleting.delete();
			this.redoBackup = deleting;
			TaskList.getInstance().updateTask(deleting);
			return ansi().fg(GREEN).a(String.format(MESSAGE_DELETE, this.parameterList.getTaskID().getValue())).reset();
		} else {
			this.redoBackup = deleting;
			TaskList.getInstance().deleteTask(this.target);
			return ansi().fg(MAGENTA).a(String.format(MESSAGE_PERMANENTLY_DELETE, this.parameterList.getTaskID().getValue())).reset();
		}
	}
	
	private String formatLogString() throws HandledException {
		assert(this.parameterList.getTaskID() != null);
		return String.format(LOG_DELETE, this.parameterList.getTaskID().getValue(), this.formatTrueAndFalse(this.parameterList.getDeleteOption() == null));
	}
	
	private String formatTrueAndFalse(boolean b) {
		return b?"true":"false";
	}

	@Override
	public InfluentialCommand undo() throws HandledException, FatalException {
		if (this.undoBackup == null) {
			return null;
		} else {
			this.undoBackup.updateLastModified(null);
			TaskList.getInstance().updateTask(this.undoBackup);
			return this;
		}
	}

	@Override
	public InfluentialCommand redo() throws HandledException, FatalException {
		if (this.redoBackup == null) {
			return null;
		} else {
			if (this.parameterList.getDeleteOption() == null && !this.redoBackup.isDeleted()) {
				this.redoBackup.updateLastModified(null);
				TaskList.getInstance().updateTask(this.redoBackup);
			} else {
				this.redoBackup.updateLastModified(null);
				TaskList.getInstance().deleteTask(this.redoBackup);
			}
			return this;
		}
	}
}

	// End of segment: CEO\src\cs2103\command\Delete.java





	/**
	 * origin: CEO\src\cs2103\command\InfluentialCommand.java
	 */

package cs2103.command;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.task.Task;

public abstract class InfluentialCommand extends Command {
	protected Task undoBackup;
	protected Task redoBackup;
	
	/**
	 * @return Command object of caller casted as InfluentialCommand
	 * @throws HandledException
	 * @throws FatalException
	 */
	public abstract InfluentialCommand undo() throws HandledException, FatalException;
	
	/**
	 * @return Command object of caller casted as InfluentialCommand
	 * @throws HandledException
	 * @throws FatalException
	 */
	public abstract InfluentialCommand redo() throws HandledException, FatalException;
	
	protected static Task cloneTask(Task task) throws HandledException {
		try {
			Task newTask = (Task) task.clone();
			return newTask;
		} catch (CloneNotSupportedException e) {
			throw new HandledException(HandledException.ExceptionType.CLONE_FAILED);
		}
	}
}

	// End of segment: CEO\src\cs2103\command\InfluentialCommand.java





	/**
	 * origin: CEO\src\cs2103\command\Mark.java
	 */

package cs2103.command;

import java.util.Date;

import org.fusesource.jansi.Ansi;

import static org.fusesource.jansi.Ansi.*;
import static org.fusesource.jansi.Ansi.Color.*;
import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.TaskID;
import cs2103.storage.TaskList;
import cs2103.task.PeriodicTask;
import cs2103.task.Task;
import cs2103.util.CommonUtil;
import cs2103.util.Logger;

public class Mark extends InfluentialCommand {
	private static final String MESSAGE_MARK = "Successfully marked task %1$d as completed\n";
	private static final String MESSAGE_MARK_FAILED = "Failed to mark task %1$d as completed\n";
	private static final String MESSAGE_MARK_NOTSUPPORTED = "Task %1$d does not support mark operation\n";
	private Task target;	
	private static final String LOG_MARK = "Executing Mark: Parameters: TaskID: %1$d";
	
	/**
	 * Creates an instance of Mark from user input
	 * @param command
	 * @throws HandledException
	 * @throws FatalException
	 */
	public Mark(String command) throws HandledException, FatalException {
		this.parameterList.addParameter(TaskID.parse(command));
		CommonUtil.checkNull(this.parameterList.getTaskID(), HandledException.ExceptionType.INVALID_TASKID);
		this.target = TaskList.getInstance().getTaskByID(this.parameterList.getTaskID().getValue());
	}

	@Override
	public Ansi execute() throws HandledException, FatalException {
		assert(this.target != null);
		Logger.getInstance().writeLog(this.formatLogString());
		if (this.target instanceof PeriodicTask) {
			return ansi().fg(RED).a(String.format(MESSAGE_MARK_NOTSUPPORTED, this.parameterList.getTaskID().getValue())).reset();
		} else {
			Task newTask = cloneTask(this.target);
			newTask.updateCompleted(new Date());
			newTask = TaskList.getInstance().updateTask(newTask);
			return this.formatReturnString(newTask);
		}
	}
	
	/**
	 * @param newTask
	 * @return Ansi formatted result string for Mark command
	 * @throws HandledException
	 */
	private Ansi formatReturnString(Task newTask) throws HandledException {
		Ansi returnString = ansi();
		if (newTask == null) {
			return returnString.fg(RED).a(String.format(MESSAGE_MARK_FAILED, this.parameterList.getTaskID().getValue())).reset();
		} else {
			this.undoBackup = this.target;
			this.redoBackup = newTask;
			returnString.fg(GREEN).a(String.format(MESSAGE_MARK, this.parameterList.getTaskID().getValue())).reset();
			return returnString.a(newTask.toDetail());
		}
	}
	
	private String formatLogString() throws HandledException {
		assert(this.parameterList.getTaskID() != null);
		return String.format(LOG_MARK, this.parameterList.getTaskID().getValue());
	}

	@Override
	public InfluentialCommand undo() throws HandledException, FatalException {
		if (this.undoBackup == null) {
			return null;
		} else {
			this.undoBackup.updateLastModified(null);
			TaskList.getInstance().updateTask(this.undoBackup);
			return this;
		}
	}
	
	@Override
	public InfluentialCommand redo() throws HandledException, FatalException {
		if (this.redoBackup == null) {
			return null;
		} else {
			this.redoBackup.updateLastModified(null);
			TaskList.getInstance().updateTask(this.redoBackup);
			return this;
		}
	}
}

	// End of segment: CEO\src\cs2103\command\Mark.java





	/**
	 * origin: CEO\src\cs2103\command\QueryCommand.java
	 */

package cs2103.command;

import java.util.ArrayList;
import cs2103.task.Task;
import org.fusesource.jansi.Ansi;
import static org.fusesource.jansi.Ansi.*;
import static org.fusesource.jansi.Ansi.Color.*;

public abstract class QueryCommand extends Command {
	private static final Ansi MESSAGE_EMPTY_LIST = ansi().bold().fg(RED).a("The task list is empty\n").reset();
	
	/**
	 * @param taskList
	 * @return Ansi formatted result string
	 */
	protected static <T extends Task> Ansi parseListResponse(ArrayList<T> taskList) {
		if (taskList == null || taskList.size() == 0) {
			return MESSAGE_EMPTY_LIST;
		} else {
			Ansi returnString = ansi();
			for (Task task:taskList) {
				returnString.a(task.toSummary()).a('\n');
			}
			return returnString;
		}
	}
}

	// End of segment: CEO\src\cs2103\command\QueryCommand.java





	/**
	 * origin: CEO\src\cs2103\command\Restore.java
	 */

package cs2103.command;

import org.fusesource.jansi.Ansi;

import static org.fusesource.jansi.Ansi.*;
import static org.fusesource.jansi.Ansi.Color.*;
import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.TaskID;
import cs2103.storage.TaskList;
import cs2103.task.Task;
import cs2103.util.CommonUtil;
import cs2103.util.Logger;

public class Restore extends InfluentialCommand {
	private static final String MESSAGE_RESTORE = "You have successfully restored a task with ID %1$d\n";
	private static final String MESSAGE_RESTORE_FAIL = "Failed to restor the task with ID %1$d\n";
	private Task target;
	private static final String LOG_RESTORE = "Executing Restore: Parameters: TaskID: %1$d";
	
	/**
	 * Creates an instance of Restore from user input
	 * @param command
	 * @throws HandledException
	 * @throws FatalException
	 */
	public Restore(String command) throws HandledException, FatalException {
		this.parameterList.addParameter(TaskID.parse(command));
		CommonUtil.checkNull(this.parameterList.getTaskID(), HandledException.ExceptionType.INVALID_CMD);
		this.target = TaskList.getInstance().getTaskByID(this.parameterList.getTaskID().getValue());
		if (!this.target.isDeleted()){
			throw new HandledException(HandledException.ExceptionType.NOT_DELETED);
		}
	}
	
	@Override
	public Ansi execute() throws HandledException, FatalException {
		assert(this.target != null);
		Logger.getInstance().writeLog(this.formatLogString());
		Ansi returnString = ansi();
		Task updating = cloneTask(this.target);
		updating.restore();
		updating = TaskList.getInstance().updateTask(updating);
		if (this.target == null) {
			return returnString.fg(RED).a(String.format(MESSAGE_RESTORE_FAIL, parameterList.getTaskID().getValue())).reset();
		} else {
			this.undoBackup = this.target;
			this.redoBackup = updating;
			returnString.fg(GREEN).a(String.format(MESSAGE_RESTORE, parameterList.getTaskID().getValue())).reset();
			return returnString.a(updating.toDetail());
		}
	}
	
	private String formatLogString() throws HandledException {
		assert(this.parameterList.getTaskID() != null);
		return String.format(LOG_RESTORE, this.parameterList.getTaskID().getValue());
	}

	@Override
	public InfluentialCommand undo() throws HandledException, FatalException {
		if (this.undoBackup == null) {
			return null;
		} else {
			this.undoBackup.updateLastModified(null);
			TaskList.getInstance().updateTask(this.undoBackup);
			return this;
		}
	}
	
	@Override
	public InfluentialCommand redo() throws HandledException, FatalException {
		if (this.redoBackup == null) {
			return null;
		} else {
			this.redoBackup.updateLastModified(null);
			TaskList.getInstance().updateTask(this.redoBackup);
			return this;
		}
	}
}

	// End of segment: CEO\src\cs2103\command\Restore.java





	/**
	 * origin: CEO\src\cs2103\command\Update.java
	 */

package cs2103.command;

import java.util.Date;
import java.util.Map;
import java.util.Queue;

import org.fusesource.jansi.Ansi;

import static org.fusesource.jansi.Ansi.*;
import static org.fusesource.jansi.Ansi.Color.*;
import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.parameters.Complete;
import cs2103.parameters.Description;
import cs2103.parameters.Location;
import cs2103.parameters.Recurrence;
import cs2103.parameters.TaskID;
import cs2103.parameters.Time;
import cs2103.parameters.Title;
import cs2103.storage.TaskList;
import cs2103.task.Task;
import cs2103.util.CommonUtil;
import cs2103.util.Logger;

public class Update extends InfluentialCommand {
	private static final String MESSAGE_UPDATE = "You have updated task with ID %1$d\n";
	private static final String MESSAGE_UPDATE_FAIL = "Fail to update task with ID %1$d\n";
	private static final String LOG_UPDATE = "Executing Update: Parameters: TaskID: %1$d\ttitle: %2$s\tdescription %2$s\tlocation: %4$s\ttime: %5$s\trecurrence: %6$s\tcomplete: %7$s";
	private static final String TIME_FORMAT = "StartTime: %1$s\tEndTime: %2$s";
	private Task target;
	
	/**
	 * Creates an instance of update from user input
	 * @param command
	 * @throws HandledException
	 * @throws FatalException
	 */
	public Update(String command) throws HandledException, FatalException {
		CommonUtil.checkNull(command, HandledException.ExceptionType.INVALID_CMD);
		Queue<String> parameterQueue = separateCommand(command);
		this.parameterList.addParameter(TaskID.parse(parameterQueue.poll()));
		Map<String, String> parameterMap = separateParameters(parameterQueue);
		this.parameterList.addParameter(Title.parse(getParameterString(parameterMap, Title.allowedLiteral)));
		this.parameterList.addParameter(Description.parse(getParameterString(parameterMap, Description.allowedLiteral)));
		this.parameterList.addParameter(Time.parse(getParameterString(parameterMap, Time.allowedLiteral)));
		this.parameterList.addParameter(Location.parse(getParameterString(parameterMap, Location.allowedLiteral)));
		this.parameterList.addParameter(Recurrence.parse(getParameterString(parameterMap, Recurrence.allowedLiteral)));
		this.parameterList.addParameter(Complete.parse(getParameterString(parameterMap, Complete.allowedLiteral)));
		if (this.parameterList.getParameterCount() <= 1) throw new HandledException(HandledException.ExceptionType.LESS_THAN_ONE_PARA);
		CommonUtil.checkNull(this.parameterList.getTaskID(), HandledException.ExceptionType.INVALID_TASKID);
		this.target = TaskList.getInstance().getTaskByID(this.parameterList.getTaskID().getValue());
	}
	
	@Override
	public Ansi execute() throws HandledException, FatalException {
		assert(this.target != null);
		Logger.getInstance().writeLog(this.formatLogString());
		Task newTask;
		if (this.parameterList.getTime() == null) {
			newTask = cloneTask(this.target);
		} else {
			newTask = this.target.updateNewTask(this.parameterList.getTime().getValue());
		}
		if (this.parameterList.getTitle() != null) {
			newTask.updateTitle(this.parameterList.getTitle().getValue());
		}
		if (this.parameterList.getDescription() != null) {
			newTask.updateDescription(this.parameterList.getDescription().getValue());
		}
		if (this.parameterList.getLocation() != null) {
			newTask.updateLocation(this.parameterList.getLocation().getValue());
		}
		if (this.parameterList.getComplete() != null) {
			newTask.updateCompleted(this.parameterList.getComplete().getValue()?new Date():null);
		}
		if (this.parameterList.getRecurrence() != null) {
			newTask.updateRecurrence(this.parameterList.getRecurrence().getValue());
		}
		newTask = TaskList.getInstance().updateTask(newTask);
		return formatReturnString(newTask);
	}
	
	/**
	 * @param newTask
	 * @return Ansi formmated string result for Update class
	 * @throws HandledException
	 */
	private Ansi formatReturnString(Task newTask) throws HandledException {
		Ansi returnString = ansi();
		if (newTask == null) {
			return returnString.fg(RED).a(String.format(MESSAGE_UPDATE_FAIL, this.parameterList.getTaskID().getValue())).reset();
		} else {
			this.undoBackup = this.target;
			this.redoBackup = newTask;
			returnString.fg(GREEN).a(String.format(MESSAGE_UPDATE, this.parameterList.getTaskID().getValue())).reset();
			return returnString.a(newTask.toDetail());
		}
	}
	
	private String readTitle() throws HandledException {
		if (this.parameterList.getTitle() == null) {
			return "null";
		} else {
			return this.parameterList.getTitle().getValue();
		}
	}
	
	private String readDescription() throws HandledException {
		if (this.parameterList.getDescription() == null) {
			return "null";
		} else {
			return this.parameterList.getDescription().getValue();
		}
	}
	
	private String readLocation() throws HandledException {
		if (this.parameterList.getLocation() == null) {
			return "null";
		} else {
			return this.parameterList.getLocation().getValue();
		}
	}
	
	private String readComplete() throws HandledException {
		if (this.parameterList.getComplete() == null) {
			return "null";
		} else {
			if (this.parameterList.getComplete().getValue()) {
				return "true";
			} else {
				return "false";
			}
		}
	}
	
	private String readRecurrence() throws HandledException {
		if (this.parameterList.getRecurrence() == null) {
			return "null";
		} else {
			if (this.parameterList.getRecurrence().getValue() == null) {
				return "No Recurrence";
			} else {
				return this.parameterList.getRecurrence().getValue().toString();
			}
		}
	}
	
	private String formatTimeString(Date[] time) {
		assert (time != null);
		return String.format(TIME_FORMAT, this.formatTimeString(time[0]), this.formatTimeString(time[1]));
	}
	
	private String formatTimeString(Date time) {
		if (time == null) {
			return "null";
		} else {
			return time.toString();
		}
	}
	
	private String readTime() throws HandledException {
		if (this.parameterList.getTime() == null) {
			return "null";
		} else {
			return this.formatTimeString(this.parameterList.getTime().getValue());
		}
	}
	
	private String formatLogString() throws HandledException {
		assert(this.parameterList.getTaskID() != null);
		return String.format(LOG_UPDATE, this.parameterList.getTaskID().getValue(), this.readTitle(), this.readDescription(), this.readLocation(), this.readTime(), this.readRecurrence(), this.readComplete());
	}
	
	@Override
	public InfluentialCommand undo() throws HandledException, FatalException {
		if (this.undoBackup == null) {
			return null;
		} else {
			this.undoBackup.updateLastModified(null);
			TaskList.getInstance().updateTask(this.undoBackup);
			return this;
		}
	}
	
	@Override
	public InfluentialCommand redo() throws HandledException, FatalException {
		if (this.redoBackup == null) {
			return null;
		} else {
			this.undoBackup.updateLastModified(null);
			TaskList.getInstance().updateTask(this.redoBackup);
			return this;
		}
	}
}

	// End of segment: CEO\src\cs2103\command\Update.java





	/**
	 * origin: CEO\src\cs2103\exception\FatalException.java
	 */

package cs2103.exception;

import cs2103.util.Logger;


public class FatalException extends Exception {
	private static final long serialVersionUID = 2812393341801137882L;
	
	private static final String ILLEGAL_FILE = "The iCalendar file is not valid, please check your file";
	private static final String WRITE_ERROR = "Encounter error while writing to the iCalendar file";
	private static final String READ_ERROR = "Encounter error while reading the iCalendar file";
	private static final String NOT_INITIALIZED = "Program has not been successfully initialized";
	private final String errorMsg;
	
	public static enum ExceptionType{
		ILLEGAL_FILE, WRITE_ERROR, READ_ERROR, NOT_INITIALIZED;
	}
	
	public FatalException(ExceptionType exceptionType) {
		this.errorMsg = getErrorMsg(exceptionType);
		Logger log = Logger.getInstance();
		log.writeErrLog(this.errorMsg, this);
	}
	
	public String printErrorMsg(){
		return this.errorMsg;
	}
	
	private String getErrorMsg(ExceptionType exceptionType){
		switch (exceptionType){
		case ILLEGAL_FILE:
			return ILLEGAL_FILE;
		case WRITE_ERROR:
			return WRITE_ERROR;
		case READ_ERROR:
			return READ_ERROR;
		case NOT_INITIALIZED:
			return NOT_INITIALIZED;
		default:
			return null;
		}
	}
}

	// End of segment: CEO\src\cs2103\exception\FatalException.java





	/**
	 * origin: CEO\src\cs2103\exception\HandledException.java
	 */

package cs2103.exception;

import cs2103.util.Logger;


public class HandledException extends Exception {
	private static final long serialVersionUID = -6882947317576882981L;
	
	private static final String INVALID_TASKID = "Your input task ID is not valid, please check your input and try again!";
	private static final String INVALID_TASK_OBJ = "An internal error occurred, operation failed.";
	private static final String INVALID_TASK_TYPE = "Your input task type is not valid, please check your input and try again!";
	private static final String INVALID_TIME = "Your input time cannot be parsed, please check your input and try again!";
	private static final String END_BEFORE_START = "Your end time is before start time, please check your input and try again";
	private static final String TASK_NOT_EXIST = "The task you intended to delete does not exist in the file.";
	private static final String INVALID_PARA = "Your input parameters are not valid, please check your input and try again!";
	private static final String INVALID_CMD = "Your input command contains error, please check your input and try again!";
	private static final String INVALID_COMPLETE = "Your input value for complete is invalid, please check your input and try again!";
	private static final String LESS_THAN_ONE_PARA = "You need to specify at least one parameter";
	private static final String CLONE_FAILED = "Failed to clone task object";
	private static final String UNEXPECTED_ERR = "An unexpected error occurred, operation failed";
	private static final String LOGIN_FAIL = "Unable to get Credential from Google, Google Sync is disabled";
	private static final String SYNC_FAIL = "Unable to sync your data with Google, Google Sync is disabled";
	private static final String NOT_DELETED = "The task you are trying to restore is not in the trash bin!";
	private static final String NO_TITLE = "You must specify a title for the task!";
	private final String errorMsg;
	
	public static enum ExceptionType{
		INVALID_TASKID, INVALID_TASK_OBJ, INVALID_TASK_TYPE, INVALID_TIME, END_BEFORE_START, TASK_NOT_EXIST, INVALID_PARA, 
		INVALID_CMD, INVALID_COMPLETE, LESS_THAN_ONE_PARA, CLONE_FAILED, UNEXPECTED_ERR, LOGIN_FAIL, SYNC_FAIL, NOT_DELETED, NO_TITLE;
	}
	
	public HandledException(ExceptionType exceptionType){
		this.errorMsg = getErrorMsg(exceptionType);
		Logger log = Logger.getInstance();
		log.writeErrLog(this.errorMsg, this);
	}
	
	public String getErrorMsg(){
		return this.errorMsg;
	}
	
	private String getErrorMsg(ExceptionType exceptionType){
		switch (exceptionType){
		case INVALID_TASKID:
			return INVALID_TASKID;
		case INVALID_TASK_OBJ:
			return INVALID_TASK_OBJ;
		case INVALID_TASK_TYPE:
			return INVALID_TASK_TYPE;
		case INVALID_TIME:
			return INVALID_TIME;
		case END_BEFORE_START:
			return END_BEFORE_START;
		case TASK_NOT_EXIST:
			return TASK_NOT_EXIST;
		case INVALID_PARA:
			return INVALID_PARA;
		case INVALID_CMD:
			return INVALID_CMD;
		case INVALID_COMPLETE:
			return INVALID_COMPLETE;
		case LESS_THAN_ONE_PARA:
			return LESS_THAN_ONE_PARA;
		case CLONE_FAILED:
			return CLONE_FAILED;
		case UNEXPECTED_ERR:
			return UNEXPECTED_ERR;
		case LOGIN_FAIL:
			return LOGIN_FAIL;
		case SYNC_FAIL:
			return SYNC_FAIL;
		case NOT_DELETED:
			return NOT_DELETED;
		case NO_TITLE:
			return NO_TITLE;
		default:
			return null;
		}
	}
}

	// End of segment: CEO\src\cs2103\exception\HandledException.java





	/**
	 * origin: CEO\src\cs2103\parameters\Parameter.java
	 */

package cs2103.parameters;

public interface Parameter {
	public String getType();
}

	// End of segment: CEO\src\cs2103\parameters\Parameter.java





	/**
	 * origin: CEO\src\cs2103\parameters\ParameterList.java
	 */

package cs2103.parameters;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import cs2103.exception.HandledException;

public class ParameterList {
	private Map<String, Parameter> parameterMap;
	
	public ParameterList() {
		parameterMap = new HashMap<String, Parameter>();
	}
	
	/**
	 * @param typeString
	 * @param type
	 * @return Parameter object that matches String typeString and type
	 * @throws HandledException
	 */
	public <T extends Parameter> T getParameter(String typeString, Class<T> type) throws HandledException {
		if (this.parameterMap.containsKey(typeString)) {
			Parameter parameter = this.parameterMap.get(typeString);
			assert(parameter != null);
			if (parameter.getClass() == type) {
				return type.cast(parameter);
			} else {
				throw new HandledException(HandledException.ExceptionType.INVALID_PARA);
			}
		} else {
			return null;
		}
	}
	
	/**
	 * Adds parameter into parameterMap
	 * @param parameter
	 */
	public void addParameter(Parameter parameter) {
		if (parameter != null) {
			parameterMap.put(parameter.getType(), parameter);
		}
	}
	
	/**
	 * Adds parameters from parameterList to parameterMap
	 * @param parameterList
	 */
	public void addAllParameters(ArrayList<Parameter> parameterList) {
		if (parameterList != null) {
			for (Parameter parameter:parameterList) {
				if (parameter != null) {
					this.addParameter(parameter);
				}
			}
		}
	}
	
	/**
	 * @return int size of parameterMap
	 */
	public int getParameterCount() {
		return this.parameterMap.size();
	}
	
	/**
	 * @return Title object from ParameterMap
	 * @throws HandledException
	 */
	public Title getTitle() throws HandledException {
		return this.getParameter(Title.type, Title.class);
	}
	
	/**
	 * @return Description object from ParameterMap
	 * @throws HandledException
	 */
	public Description getDescription() throws HandledException {
		return this.getParameter(Description.type, Description.class);
	}
	
	/**
	 * @return Location object from ParameterMap
	 * @throws HandledException
	 */
	public Location getLocation() throws HandledException {
		return this.getParameter(Location.type, Location.class);
	}
	
	/**
	 * @return Time object from ParameterMap
	 * @throws HandledException
	 */
	public Time getTime() throws HandledException {
		return this.getParameter(Time.type, Time.class);
	}
	
	/**
	 * @return Complete object from ParameterMap
	 * @throws HandledException
	 */
	public Complete getComplete() throws HandledException {
		return this.getParameter(Complete.type, Complete.class);
	}
	
	/**
	 * @return Recurrence object from ParameterMap
	 * @throws HandledException
	 */
	public Recurrence getRecurrence() throws HandledException {
		return this.getParameter(Recurrence.type, Recurrence.class);
	}
	
	/**
	 * @return TaskID object from ParameterMap
	 * @throws HandledException
	 */
	public TaskID getTaskID() throws HandledException {
		return this.getParameter(TaskID.type, TaskID.class);
	}
	
	public TaskType getTaskType() throws HandledException {
		return this.getParameter(TaskType.type, TaskType.class);
	}
	
	/**
	 * @return CommandType object from ParameterMap
	 * @throws HandledException
	 */
	public CommandType getCommandType() throws HandledException {
		return this.getParameter(CommandType.type, CommandType.class);
	}
	
	/**
	 * @return Keyword object from ParameterMap
	 * @throws HandledException
	 */
	public Keyword getKeyword() throws HandledException {
		return this.getParameter(Keyword.type, Keyword.class);
	}
	
	/**
	 * @return Delete object from ParameterMap
	 * @throws HandledException
	 */
	public DeleteOption getDeleteOption() throws HandledException {
		return this.getParameter(DeleteOption.type, DeleteOption.class);
	}
	
	/**
	 * @return Option object from ParameterMap
	 * @throws HandledException
	 */
	public Option getOption() throws HandledException {
		return this.getParameter(Option.type, Option.class);
	}
}

	// End of segment: CEO\src\cs2103\parameters\ParameterList.java





	/**
	 * origin: CEO\src\cs2103\parameters\Recurrence.java
	 */

package cs2103.parameters;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import cs2103.exception.HandledException;
import cs2103.util.CommonUtil;
import net.fortuna.ical4j.model.Recur;

public class Recurrence implements Parameter {
	public static final String[] allowedLiteral = {"R", "reccuring", "recur"};
	public static final String type = "RECURRENCE";
	private final Recur recur;
	
	/**
	 * @param recur
	 */
	public Recurrence(Recur recur) {
		this.recur = recur;
	}
	
	/**
	 * @return Recur object of Recurrence
	 */
	public Recur getValue() {
		return this.recur;
	}

	@Override
	public String getType() {
		return type;
	}
	
	/**
	 * @param recurrenceString
	 * @return Recurrence object of String recurrenceString
	 * @throws HandledException
	 */
	public static Recurrence parse(String recurrenceString) throws HandledException {
		if (recurrenceString == null) {
			return null;
		} else {
			return new Recurrence(stringToRecur(recurrenceString));
		}
	}
	
	/**
	 * @param recurrenceString
	 * @return Recur object from String recurrenceString, or null if String recurrenceString does not specify a correct recurring period
	 * @throws HandledException
	 */
	private static Recur stringToRecur(String recurrenceString) throws HandledException {
		int interval = parseInterval(recurrenceString);
		if (interval == 0) {
			return null;
		} else {
			String frequency = parseFrequency(recurrenceString);
			if (frequency == null) {
				return null;
			} else {
				Recur recur=new Recur();
				recur.setFrequency(frequency);
				recur.setInterval(interval);
				return recur;
			}
		}
	}
	
	/**
	 * @param recurrenceString
	 * @return int value of recurrence period, or 1 if recurrence period cannot be found
	 * @throws HandledException
	 */
	private static int parseInterval(String recurrenceString) throws HandledException {
		Pattern p = Pattern.compile("([0-9]+)");
		Matcher m = p.matcher(recurrenceString);
		if (m.find()) {
			recurrenceString = recurrenceString.substring(m.start()).trim();
			return CommonUtil.parseIntegerParameter(m.group(0));
		} else {
			return 1;
		}
	}
	
	/**
	 * @param recurrenceString
	 * @return String time counter(hourly, daily etc) for recurrence, or null if time counter cannot be found
	 * @throws HandledException
	 */
	private static String parseFrequency(String recurrenceString) throws HandledException {
		Pattern p = Pattern.compile("([A-Za-z]+)");
		Matcher m = p.matcher(recurrenceString);
		while (m.find()) {
			String found=m.group(0);
			if (found.equalsIgnoreCase("h") || found.equalsIgnoreCase("hour") || found.equalsIgnoreCase("hours") || found.equalsIgnoreCase("hourly")) {
				return Recur.HOURLY;
			} else if (found.equalsIgnoreCase("d") || found.equalsIgnoreCase("day") || found.equalsIgnoreCase("days") || found.equalsIgnoreCase("daily")) {
				return Recur.DAILY;
			} else if (found.equalsIgnoreCase("w") || found.equalsIgnoreCase("week") || found.equalsIgnoreCase("weeks") || found.equalsIgnoreCase("weekly")) {
				return Recur.WEEKLY;
			} else if (found.equalsIgnoreCase("m") || found.equalsIgnoreCase("month") || found.equalsIgnoreCase("months") || found.equalsIgnoreCase("monthly")) {
				return Recur.MONTHLY;
			} else if (found.equalsIgnoreCase("y") || found.equalsIgnoreCase("year") || found.equalsIgnoreCase("years") || found.equalsIgnoreCase("yearly")) {
				return Recur.YEARLY;
			}
		}
		return null;
	}
}

	// End of segment: CEO\src\cs2103\parameters\Recurrence.java





	/**
	 * origin: CEO\src\cs2103\parameters\Time.java
	 */

package cs2103.parameters;

import java.util.Date;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

public class Time implements Parameter {
	public static final String[] allowedLiteral = {"T", "time"};
	public static final String type = "TIME";
	private final Date[] time;
	
	public Time(Date[] time) {
		this.time = time;
	}
	
	/**
	 * @return Date Array from Time
	 */
	public Date[] getValue() {
		return this.time;
	}
	
	@Override
	public String getType() {
		return type;
	}

	/**
	 * @param timeString
	 * @return Time object from String timeString
	 */
	public static Time parse(String timeString) {
		if (timeString == null) {
			return null;
		} else {
			return new Time(parseTime(timeString));
		}
	}
	
	/**
	 * @param timeString
	 * @return Date Array from String timeString, contains only one Date object if timeString contains only one date(DeadlineTask),  
	 * contains two Date objects if timeString contains two dates(PeriodicTask)
	 */
	private static Date[] parseTime(String timeString) {
		Date[] time = new Date[2];
		if (timeString != null) {
			java.util.List<Date> dates = new PrettyTimeParser().parse(timeString);
			if (!dates.isEmpty()) {
				for (int i = 0;i < dates.size() && i < 2;i++){
					time[i] = dates.get(i);
				}
			}
		}
		return time;
	}
}

	// End of segment: CEO\src\cs2103\parameters\Time.java





	/**
	 * origin: CEO\src\cs2103\storage\AuthStoreFactory.java
	 */

package cs2103.storage;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import com.google.api.client.util.IOUtils;
import com.google.api.client.util.Lists;
import com.google.api.client.util.Maps;
import com.google.api.client.util.Preconditions;
import com.google.api.client.util.store.AbstractDataStore;
import com.google.api.client.util.store.AbstractDataStoreFactory;
import com.google.api.client.util.store.DataStore;
import com.google.api.client.util.store.DataStoreUtils;
import com.google.api.client.util.store.FileDataStoreFactory;

/**
 * This class extends AbstractDataStoreFactory in Google client API library.
 * Used to create a qualified local data store for Google authentication
 */
public class AuthStoreFactory extends AbstractDataStoreFactory {
	private final File dataDirectory;
	
	public AuthStoreFactory() {
		this.dataDirectory = new File(".");
	}
	
	public final File getDataDirectory() {
	    return dataDirectory;
	}
	
	@Override
	protected <V extends Serializable> DataStore<V> createDataStore(String id) throws IOException {
		return new FileDataStore<V>(this, dataDirectory, id);
	}
	
	static class FileDataStore<V extends Serializable> extends AbstractDataStore<V> {
		private final Lock lock = new ReentrantLock();
		HashMap<String, byte[]> keyValueMap = Maps.newHashMap();
	    private final File dataFile;

	    FileDataStore(AuthStoreFactory dataStore, File dataDirectory, String id) throws IOException {
	    	super(dataStore, id);
	    	this.dataFile = new File(dataDirectory, id);
	    	if (dataFile.createNewFile()) {
	    		keyValueMap = Maps.newHashMap();
	    		save();
	    	} else {
	    		keyValueMap = IOUtils.deserialize(new FileInputStream(dataFile));
	    	}
	    }

	    void save() throws IOException {
	    	IOUtils.serialize(keyValueMap, new FileOutputStream(dataFile));
	    }

	    @Override
	    public FileDataStoreFactory getDataStoreFactory() {
	    	return (FileDataStoreFactory) super.getDataStoreFactory();
	    }

		@Override
		public Set<String> keySet() throws IOException {
			lock.lock();
		    try {
		    	return Collections.unmodifiableSet(keyValueMap.keySet());
		    } finally {
		    	lock.unlock();
		    }
		}

		@Override
		public Collection<V> values() throws IOException {
			lock.lock();
		    try {
		    	List<V> result = Lists.newArrayList();
		    	for (byte[] bytes : keyValueMap.values()) {
		    		result.add(IOUtils.<V>deserialize(bytes));
		    	}
		    	return Collections.unmodifiableList(result);
		    } finally {
		    	lock.unlock();
		    }
		}

		@Override
		public V get(String key) throws IOException {
			if (key == null) {
				return null;
			}
			lock.lock();
			try {
				return IOUtils.deserialize(keyValueMap.get(key));
			} finally {
			    lock.unlock();
			}
		}

		@Override
		public DataStore<V> set(String key, V value) throws IOException {
			Preconditions.checkNotNull(key);
		    Preconditions.checkNotNull(value);
		    lock.lock();
		    try {
		    	keyValueMap.put(key, IOUtils.serialize(value));
		    	save();
		    } finally {
		    	lock.unlock();
		    }
		    return this;
		}

		@Override
		public DataStore<V> clear() throws IOException {
			lock.lock();
		    try {
		    	keyValueMap.clear();
		    	save();
		    } finally {
		    	lock.unlock();
		    }
		    return this;
		}

		@Override
		public DataStore<V> delete(String key) throws IOException {
			if (key == null) {
				return this;
			}
			lock.lock();
			try {
				keyValueMap.remove(key);
				save();
			} finally {
				lock.unlock();
			}
			return this;
		}
		
		@Override
		public boolean containsKey(String key) throws IOException {
		  	if (key == null) {
		    	return false;
		    }
		    lock.lock();
		    try {
		    	return keyValueMap.containsKey(key);
		    } finally {
		    	lock.unlock();
		    }
		}

		@Override
		public boolean containsValue(V value) throws IOException {
			if (value == null) {
				return false;
			}
			lock.lock();
			try {
				byte[] serialized = IOUtils.serialize(value);
				for (byte[] bytes : keyValueMap.values()) {
					if (Arrays.equals(serialized, bytes)) {
						return true;
					}
				}
				return false;
			} finally {
				lock.unlock();
			}
		}

		@Override
		public boolean isEmpty() throws IOException {
			lock.lock();
			try {
				return keyValueMap.isEmpty();
			} finally {
				lock.unlock();
			}
		}

		@Override
		public int size() throws IOException {
			lock.lock();
			try {
				return keyValueMap.size();
			} finally {
				lock.unlock();
			}
		}

		@Override
		public String toString() {
			return DataStoreUtils.toString(this);
		}
	}
}

	// End of segment: CEO\src\cs2103\storage\AuthStoreFactory.java





	/**
	 * origin: CEO\src\cs2103\storage\GoogleEngine.java
	 */

package cs2103.storage;

import java.io.IOException;
import java.security.GeneralSecurityException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import net.fortuna.ical4j.model.Recur;
import net.fortuna.ical4j.model.property.Status;

import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.services.calendar.model.CalendarList;
import com.google.api.services.calendar.model.CalendarListEntry;

import cs2103.exception.HandledException;
import cs2103.task.*;
import cs2103.util.CommonUtil;
import cs2103.util.Logger;

/**
 * Read and write Task objects to Google Calendar and Google Tasks
 */
public class GoogleEngine {
	private static GoogleEngine storage;
	private final GoogleReceiver receiver;
	private final String calendarIdentifier;
	private final Logger logger;
	private com.google.api.services.calendar.Calendar calendar;
	private com.google.api.services.tasks.Tasks tasks;
	private Date taskLastUpdate;
	private Date calendarLastUpdate;
	private static final long DAY_IN_MILLIS = 86400000L;
	private static final int DUE_STRING_LENGTH = 8;
	private static final String DEFAULT_TASKS = "@default";
	private static final String LOG_ADD = "Adding task with UID %1$s to Google";
	private static final String LOG_UPDATE = "Updating task with UID %1$s to Google";
	private static final String LOG_REMOVE = "Removing task with UID %1$s from Google";
	private static final String LOG_INITIALIZE = "Initializing GoogleEngine";
	private static final String RRULE_PREFIX = "RRULE:";
	
	private GoogleEngine() throws HandledException {
		try {
			this.logger = Logger.getInstance();
			this.logger.writeLog(LOG_INITIALIZE);
			this.receiver = new GoogleReceiver();
			this.calendar = this.receiver.getCalendarClient();
			this.tasks = this.receiver.getTasksClient();
			this.calendarIdentifier = this.getIdentifier();
			this.updateLastUpdated();
		} catch (IOException | GeneralSecurityException e) {
			throw new HandledException(HandledException.ExceptionType.LOGIN_FAIL);
		}
	}
	
	/**
	 * @return The default instance of this class
	 * @throws HandledException
	 */
	public static GoogleEngine getInstance() throws HandledException {
		if (storage == null) {
			storage = new GoogleEngine();
		}
		return storage;
	}
	
	/**
	 * delete the task from Google Calendar or Google Tasks if it exists
	 * @param Task
	 * @throws IOException
	 * @throws HandledException
	 */
	public void deleteTask(Task task) throws IOException, HandledException {
		CommonUtil.checkNull(task, HandledException.ExceptionType.INVALID_TASK_OBJ);
		this.logger.writeLog(CommonUtil.formatLogString(LOG_REMOVE, task));
		try {
			this.tryToRemove(task);
		} catch (IOException e) {
			try {
				this.reinitialize();
				this.tryToRemove(task);
			} catch (IOException e1) {
				throw e1;
			}
		}
	}
	
	/**
	 * Update the Task in Google Calendar or Google Tasks if it exist. 
	 * @param Task
	 * @return Return the update result if available
	 * @throws IOException
	 * @throws HandledException
	 */
	public Task updateTask(Task task) throws IOException, HandledException {
		CommonUtil.checkNull(task, HandledException.ExceptionType.INVALID_TASK_OBJ);
		this.logger.writeLog(CommonUtil.formatLogString(LOG_UPDATE, task));
		try {
			return this.tryToUpdate(task);
		} catch (IOException e) {
			try {
				this.reinitialize();
				return this.tryToUpdate(task);
			} catch (IOException e1) {
				throw e1;
			}
		}
	}

	/**
	 * Insert the Task into either Google Calendar or Google Tasks. If the task exists, an IOExcpetion will be thrown
	 * @param Task
	 * @throws HandledException
	 * @throws IOException
	 */
	public Task addTask(Task task) throws HandledException, IOException {
		CommonUtil.checkNull(task, HandledException.ExceptionType.INVALID_TASK_OBJ);
		this.logger.writeLog(CommonUtil.formatLogString(LOG_ADD, task));
		try {
			return this.tryToInsert(task);
		} catch (IOException e) {
			try {
				this.reinitialize();
				return this.tryToInsert(task);
			} catch (IOException e1) {
				throw e1;
			}
		}
	}

	/**
	 * @return Parse the Google Calendar and Google Tasks entries into Task objects and return an ArrayList of them
	 * @throws HandledException
	 */
	public ArrayList<Task> getTaskList() throws HandledException  {
		ArrayList<Task> taskList = new ArrayList<Task>();
		for (com.google.api.services.calendar.model.Event gEvent:this.getEvents()) {
			taskList.add(this.parseGEvent(gEvent));
		}
		for (com.google.api.services.tasks.model.Task gTask:this.getTasks()) {
			taskList.add(this.parseGTask(gTask));
		}
		return taskList;
	}
	
	/**
	 * update the stored last update time of Google Calendar and Google Tasks list
	 * @throws IOException
	 */
	public void updateLastUpdated() throws IOException {
		try {
			this.tryToGetLastUpdated();
		} catch (IOException e) {
			try {
				this.reinitialize();
				this.tryToGetLastUpdated();
			} catch (IOException e1) {
				throw e1;
			}
		}
	}
	
	/**
	 * @param Task
	 * @return Return if a sync is necessary, i.e. whether the Google Calendar or Google Tasks list is modified since last sync
	 * @throws IOException
	 * @throws HandledException 
	 */
	public boolean needToSync(Task task) throws IOException, HandledException{
		CommonUtil.checkNull(task, HandledException.ExceptionType.INVALID_TASK_OBJ);
		assert(this.calendarLastUpdate != null);
		assert(this.taskLastUpdate != null);
		Date calendarLastUpdateSaved = this.calendarLastUpdate;
		Date taskLastUpdateSaved = this.taskLastUpdate;
		this.updateLastUpdated();
		if (task instanceof EventTask) {
			return this.calendarLastUpdate.after(calendarLastUpdateSaved);
		} else if (task instanceof ToDoTask) {
			return this.taskLastUpdate.after(taskLastUpdateSaved);
		} else {
			return false;
		}
	}
	
	private Task parseGTask(com.google.api.services.tasks.model.Task gTask) throws HandledException {
		CommonUtil.checkNull(gTask, HandledException.ExceptionType.INVALID_TASK_OBJ);
		String[] descriptionAndDueTime = this.splitDescriptionAndDueTime(gTask); //Work around for Google Tasks storing only date but not time
		String description = descriptionAndDueTime[0];
		Date dueTime = this.readDueTime(gTask.getDue(), descriptionAndDueTime[1]); //Adjust according to time stored in description
		ToDoTask task;
		if (dueTime == null) {
			task = new FloatingTask(gTask.getId(), this.readStatus(gTask));
		} else {
			task = new DeadlineTask(gTask.getId(), this.readStatus(gTask), dueTime);
		}
		assert(task != null);
		task.updateTitle(gTask.getTitle());
		task.updateCreated(this.readLastModified(gTask));
		task.updateCompleted(this.readCompleted(gTask));
		task.updateDescription(description);
		task.updateLastModified(this.readLastModified(gTask));
		return task;
	}
	
	private Task parseGEvent(com.google.api.services.calendar.model.Event gEvent) throws HandledException {
		CommonUtil.checkNull(gEvent, HandledException.ExceptionType.INVALID_TASK_OBJ);
		Date[] time = this.readTime(gEvent);
		assert(time != null);
		PeriodicTask task = new PeriodicTask(gEvent.getId(), this.readStatus(gEvent), time[0], time[1]);
		assert(task != null);
		task.updateTitle(gEvent.getSummary());
		task.updateCreated(this.readCreated(gEvent));
		task.updateLocation(gEvent.getLocation());
		task.updateRecurrence(this.readRecurrence(gEvent));
		task.updateDescription(gEvent.getDescription());
		task.updateLastModified(this.readLastModified(gEvent));
		return task;
	}
	
	private Task tryToInsert(Task task) throws IOException, HandledException {
		assert(task != null);
		if (task.isDeleted()) {
			return null;
		} else {
			Task returnTask = this.executeInsert(task);
			assert(task.getCreated() != null);
			returnTask.updateCreated(task.getCreated());
			return returnTask;
		}
	}
	
	private Task executeInsert(Task task) throws HandledException, IOException {
		if (task instanceof EventTask) {
			com.google.api.services.calendar.model.Event insertEvent = ((EventTask) task).toGEvent();
			return parseGEvent(this.calendar.events().insert(calendarIdentifier, insertEvent).execute());
		} else if (task instanceof ToDoTask) {
			com.google.api.services.tasks.model.Task insertTask = ((ToDoTask) task).toGTask();
			return parseGTask(this.tasks.tasks().insert(DEFAULT_TASKS, insertTask).execute());
		} else {
			throw new HandledException(HandledException.ExceptionType.INVALID_TASK_OBJ);
		}
	}
	
	private void tryToRemove(Task task) throws IOException {
		assert(task != null);
		if (task instanceof EventTask){
			if (!this.checkRemoved((EventTask) task)) {
				this.calendar.events().delete(calendarIdentifier, task.getTaskUID()).execute();
			}
		} else if (task instanceof ToDoTask) {
			if (!this.checkRemoved((ToDoTask) task)){
				this.tasks.tasks().delete(DEFAULT_TASKS, task.getTaskUID()).execute();
			}
		}
	}
	
	private boolean checkRemoved(EventTask task) throws IOException {
		assert(task != null);
		try {
			com.google.api.services.calendar.model.Event gEvent = this.calendar.events().get(calendarIdentifier, task.getTaskUID()).execute();
			return gEvent == null || gEvent.getStatus().equals("cancelled");
		} catch (GoogleJsonResponseException e) {
			return false;
		}
	}
	
	private boolean checkRemoved(ToDoTask task) throws IOException {
		assert(task != null);
		try {
			com.google.api.services.tasks.model.Task gTask = this.tasks.tasks().get(DEFAULT_TASKS, task.getTaskUID()).execute();
			return gTask == null || (gTask.getDeleted() != null && gTask.getDeleted());
		} catch (GoogleJsonResponseException e) {
			return false;
		}
	}
	
	private Task tryToUpdate(Task task) throws IOException, HandledException {
		assert(task != null);
		if (task.isDeleted()){
			this.tryToRemove(task);
			return null;
		} else {
			Task returnTask = this.executeUpdate(task);
			assert(task.getCreated() != null);
			returnTask.updateCreated(task.getCreated());
			return returnTask;
		}
	}
	
	private Task executeUpdate(Task task) throws HandledException, IOException {
		if (task instanceof EventTask) {
			return this.executeUpdate((EventTask) task); 
		} else if (task instanceof ToDoTask) {
			return this.executeUpdate((ToDoTask) task);
		} else {
			throw new HandledException(HandledException.ExceptionType.INVALID_TASK_OBJ);
		}
	}
	
	private Task executeUpdate(EventTask task) throws IOException, HandledException {
		assert(task != null);
		if (this.checkConverting(task)) {
			this.tasks.tasks().delete(DEFAULT_TASKS, task.getTaskUID()).execute();
			return this.tryToInsert(task);
		} else {
			com.google.api.services.calendar.model.Event existing = this.calendar.events().get(calendarIdentifier, task.getTaskUID()).execute();
			if (existing == null) {
				return this.tryToInsert(task);
			} else {
				com.google.api.services.calendar.model.Event updating = task.toGEvent();
				updating.setSequence(this.readSequence(existing));
				return parseGEvent(this.calendar.events().patch(calendarIdentifier, existing.getId(), updating).execute());
			}
		}
	}
	
	private boolean checkConverting(EventTask task) throws IOException {
		assert(task != null);
		try {
			return this.tasks.tasks().get(DEFAULT_TASKS, task.getTaskUID()).execute() != null;
		} catch (GoogleJsonResponseException e) {
			return false;
		}
	}
	
	private Task executeUpdate(ToDoTask task) throws IOException, HandledException {
		assert(task != null);
		if (this.checkConverting(task)) {
			this.calendar.events().delete(calendarIdentifier, task.getTaskUID()).execute();
			return this.tryToInsert(task);
		} else {
			com.google.api.services.tasks.model.Task gTask = this.tasks.tasks().get(DEFAULT_TASKS, task.getTaskUID()).execute();
			if (gTask == null) {
				return this.tryToInsert(task);
			} else {
				com.google.api.services.tasks.model.Task newGTask = task.toGTask();
				newGTask.setDeleted(false);
				return parseGTask(this.tasks.tasks().patch(DEFAULT_TASKS, gTask.getId(), newGTask).execute());
			}
		}
	}
	
	private boolean checkConverting(ToDoTask task) throws IOException {
		assert(task != null);
		try {
			return this.calendar.events().get(calendarIdentifier, task.getTaskUID()).execute() != null;
		} catch (GoogleJsonResponseException e) {
			return false;
		}
	}

	private void tryToGetLastUpdated() throws IOException {
		this.calendarLastUpdate =  new Date(this.calendar.events().list(calendarIdentifier).setShowDeleted(true).execute().getUpdated().getValue());
		this.taskLastUpdate = new Date(this.tasks.tasklists().get(DEFAULT_TASKS).execute().getUpdated().getValue());
	}
	
	private int readSequence(com.google.api.services.calendar.model.Event gEvent) {
		assert(gEvent != null);
		if (gEvent.getSequence() == null) {
			return 2;
		} else {
			return gEvent.getSequence() + 1;
		}
	}
	
	private Date readCompleted(com.google.api.services.tasks.model.Task gTask) {
		assert(gTask != null);
		if (gTask.getCompleted() == null) {
			return null;
		} else {
			return new Date(gTask.getCompleted().getValue());
		}
	}
	
	private Date readLastModified(com.google.api.services.tasks.model.Task gTask) {
		assert(gTask != null);
		if (gTask.getUpdated() == null) {
			return new Date();
		} else {
			return new Date(gTask.getUpdated().getValue());
		}
	}
	
	private Date readLastModified(com.google.api.services.calendar.model.Event gEvent) {
		assert(gEvent != null);
		if (gEvent.getUpdated() == null) {
			return new Date();
		} else {
			return new Date(gEvent.getUpdated().getValue());
		}
	}
	
	private Date readCreated(com.google.api.services.calendar.model.Event gEvent) {
		assert(gEvent != null);
		if (gEvent.getCreated() == null) {
			return new Date();
		} else {
			return new Date(gEvent.getCreated().getValue());
		}
	}
	
	private Date[] readTime(com.google.api.services.calendar.model.Event gEvent) throws HandledException {
		assert(gEvent != null);
		Date[] time = new Date[2];
		CommonUtil.checkNull(gEvent.getStart(), HandledException.ExceptionType.INVALID_TIME);
		com.google.api.client.util.DateTime startTime = this.readEventDateTime(gEvent.getStart());
		CommonUtil.checkNull(startTime, HandledException.ExceptionType.INVALID_TIME);
		time[0] = new Date(startTime.getValue());
		com.google.api.client.util.DateTime endTime = this.readEventDateTime(gEvent.getEnd());
		if (endTime == null) {
			time[1] = new Date(time[0].getTime() + DAY_IN_MILLIS);
		} else {
			time[1] = new Date(endTime.getValue());
		}
		return time;
	}

	private com.google.api.client.util.DateTime readEventDateTime(com.google.api.services.calendar.model.EventDateTime edt) {
		if (edt == null) {
			return null;
		} else {
			if (edt.getDateTime() == null) {
				return edt.getDate();
			} else {
				return edt.getDateTime();
			}
		}
	}
	
	private Date readDueTime(com.google.api.client.util.DateTime dueTime, String supplement) {
		if (dueTime == null) {
			return null;
		} else if (supplement == null) {
			return this.getDefaultDueTime(dueTime.getValue());
		} else {
			return this.adjustDueTime(dueTime.getValue(), supplement);
		}
	}
	
	private Date getDefaultDueTime(long dueTime) {
		Calendar cal = Calendar.getInstance();
		cal.setTimeInMillis(dueTime);
		cal.set(Calendar.HOUR_OF_DAY, 23);
		cal.set(Calendar.MINUTE, 59);
		return new Date(cal.getTimeInMillis());
	}
	
	private Date adjustDueTime(long dueTime, String supplement) {
		Calendar adjusting = Calendar.getInstance();
		Calendar adjustment = this.parseSupplement(supplement);
		adjusting.setTimeInMillis(dueTime);
		if (adjustment != null) {
			adjusting.set(Calendar.HOUR_OF_DAY, adjustment.get(Calendar.HOUR_OF_DAY));
			adjusting.set(Calendar.MINUTE, adjustment.get(Calendar.MINUTE));
		}
		return new Date(adjusting.getTimeInMillis());
	}
	
	private Calendar parseSupplement(String supplement) {
		assert(supplement != null);
		java.util.List<Date> dates = new PrettyTimeParser().parse(supplement);
		if (!dates.isEmpty()){
			Calendar cal = Calendar.getInstance();
			cal.setTimeInMillis(dates.get(0).getTime());
			return cal;
		} else {
			return null;
		}
	}
	
	private Recur readRecurrence(com.google.api.services.calendar.model.Event gEvent) {
		assert(gEvent != null);
		if (gEvent.getRecurrence() == null) {
			return null;
		} else {
			String recurString = getRecurrenceString(gEvent.getRecurrence());
			return parseRecurrence(recurString);
		}
	}
	
	private String getRecurrenceString(List<String> recurrenceList) {
		assert(recurrenceList != null);
		for (String s: recurrenceList){
			if (s != null && s.startsWith(RRULE_PREFIX)) return s.substring(RRULE_PREFIX.length());
		}
		return null;
	}
	
	private static Recur parseRecurrence(String recurString) {
		if (recurString == null){
			return null;
		} else {
			try {
				Recur recur = new Recur(recurString);
				if (recur.getInterval() < 1) recur.setInterval(1);
				return recur;
			} catch (ParseException e) {
				return null;
			}
		}
	}
	
	private Status readStatus(com.google.api.services.calendar.model.Event gEvent) {
		assert(gEvent != null);
		if (gEvent.getStatus() == null) {
			return null;
		} else {
			return new Status(gEvent.getStatus().toUpperCase());
		}
	}
	
	private Status readStatus(com.google.api.services.tasks.model.Task gTask) {
		assert(gTask != null);
		if (gTask.getDeleted() != null && gTask.getDeleted()) {
			return Status.VTODO_CANCELLED;
		} else if (gTask.getStatus() == null) {
			return Status.VTODO_NEEDS_ACTION;
		} else if (gTask.getStatus().equalsIgnoreCase("COMPLETED")) {
			return Status.VTODO_COMPLETED;
		} else {
			return Status.VTODO_NEEDS_ACTION;
		}
	}
	
	private String[] splitDescriptionAndDueTime(com.google.api.services.tasks.model.Task gTask) {
		assert(gTask != null);
		String[] result = new String[2];
		String description = gTask.getNotes();
		if (description == null) {
			return result; 
		}
		Pattern p = Pattern.compile("(\n<Due At: \\d+:\\d+ \\w+>)");
		Matcher m = p.matcher(gTask.getNotes());
		if (m.find()){
			result[0] = description.substring(0, m.start()).trim();
			result[1] = description.substring(m.start() + DUE_STRING_LENGTH , m.end() - 1);
		} else {
			result[0] = description;
		}
		return result;
	}
	
	private List<com.google.api.services.tasks.model.Task> getTasks() throws HandledException {
		try {
			assert(this.tasks != null);
			return this.tasks.tasks().list(DEFAULT_TASKS).setShowDeleted(true).execute().getItems();
		} catch (IOException e) {
			try {
				this.tasks = this.receiver.getTasksClient();
				return this.tasks.tasks().list(DEFAULT_TASKS).setShowDeleted(true).execute().getItems();
			} catch (IOException e1) {
				this.logger.writeErrLog(e1.getMessage(), e1);
				throw new HandledException(HandledException.ExceptionType.SYNC_FAIL);
			}
		}
	}
	
	private List<com.google.api.services.calendar.model.Event> getEvents() throws HandledException {
		try {
			assert(this.calendar != null);
			return this.calendar.events().list(calendarIdentifier).setShowDeleted(true).execute().getItems();
		} catch (IOException e) {
			try {
				this.calendar = this.receiver.getCalendarClient();
				return this.calendar.events().list(calendarIdentifier).setShowDeleted(true).execute().getItems();
			} catch (IOException e1) {
				this.logger.writeErrLog(e1.getMessage(), e1);
				throw new HandledException(HandledException.ExceptionType.SYNC_FAIL);
			}
		}
	}
	
	private void reinitialize() throws IOException {
		this.calendar = this.receiver.getCalendarClient();
		this.tasks = this.receiver.getTasksClient();
	}
	
	private String getIdentifier() throws HandledException{
		try {
			CalendarList feed = this.calendar.calendarList().list().execute();
			CommonUtil.checkNull(feed, HandledException.ExceptionType.SYNC_FAIL);
		    for (CalendarListEntry entry : feed.getItems()) {
		    	if (entry.isPrimary()) return entry.getId();
		    }
		    throw new HandledException(HandledException.ExceptionType.SYNC_FAIL);
		} catch (IOException e) {
			this.logger.writeErrLog(e.getMessage(), e);
			throw new HandledException(HandledException.ExceptionType.SYNC_FAIL);
		}
	}
}

	// End of segment: CEO\src\cs2103\storage\GoogleEngine.java





	/**
	 * origin: CEO\src\cs2103\storage\GoogleEngineTest.java
	 */

package cs2103.storage;

import static org.junit.Assert.*;

import java.io.IOException;

import net.fortuna.ical4j.model.DateTime;

import org.junit.Before;
import org.junit.Test;

import cs2103.exception.HandledException;
import cs2103.task.*;

public class GoogleEngineTest {
	private GoogleEngine google;
	private static final long DAY_IN_MILLIS = 86400000L;
	
	@Before
	public void setUp() throws Exception {
		this.google = GoogleEngine.getInstance();
	}

	@Test
	public void testFloatingTask() throws HandledException, IOException {
		ToDoTask testTask = new FloatingTask(null, null);
		testTask.updateTitle("Tiro Finale");
		testTask.updateDescription("Nanimo kowakunai");
		testTask = (ToDoTask) this.google.addTask(testTask);
		assertEquals("Tiro Finale", testTask.getTitle());
		assertEquals("Nanimo kowakunai", testTask.getDescription());
		DateTime completed = new DateTime();
		testTask.updateCompleted(completed);
		testTask = (ToDoTask) this.google.updateTask(testTask);
		assertEquals(completed.getTime(), testTask.getCompleted().getTime());
		boolean success = false;
		for (Task task:this.google.getTaskList()) {
			if (!task.isDeleted() && task.equals(testTask)) success = true;
		}
		assertTrue(success);
		this.google.deleteTask(testTask);
		for (Task task:this.google.getTaskList()) {
			if (!task.isDeleted() && task.equals(testTask)) fail();
		}
	}
	
	@Test
	public void testDeadlineTask() throws HandledException, IOException {
		ToDoTask testTask = new DeadlineTask(null, null, new DateTime());
		testTask.updateTitle("TwinTails");
		testTask.updateDescription("Tail On!");
		testTask = (ToDoTask) this.google.addTask(testTask);
		assertEquals("TwinTails", testTask.getTitle());
		assertEquals("Tail On!", testTask.getDescription());
		DateTime completed = new DateTime();
		testTask.updateCompleted(completed);
		testTask = (ToDoTask) this.google.updateTask(testTask);
		assertEquals(completed.getTime(), testTask.getCompleted().getTime());
		boolean success = false;
		for (Task task:this.google.getTaskList()){
			if (!task.isDeleted() && task.equals(testTask)) success = true;
		}
		assertTrue(success);
		this.google.deleteTask(testTask);
		for (Task task:this.google.getTaskList()){
			if (!task.isDeleted() && task.equals(testTask)) fail();
		}
	}
	
	@Test
	public void testPeriodicTask() throws HandledException, IOException {
		DateTime startTime = new DateTime();
		DateTime endTime = new DateTime(startTime.getTime() + DAY_IN_MILLIS);
		EventTask testTask = new PeriodicTask(null, null, startTime, endTime);
		testTask.updateTitle("Anata no tame nara");
		testTask.updateDescription("Watashi ha eien no meiron ni tochikomeraredemo, kamawanai");
		testTask.updateLocation("Mitakihara");
		testTask = (EventTask) this.google.addTask(testTask);
		assertEquals("Anata no tame nara", testTask.getTitle());
		assertEquals("Watashi ha eien no meiron ni tochikomeraredemo, kamawanai", testTask.getDescription());
		assertEquals("Mitakihara", ((PeriodicTask) testTask).getLocation());
		assertEquals(startTime.getTime(), testTask.getStartTime().getTime());
		assertEquals(endTime.getTime(), testTask.getEndTime().getTime());
		boolean success = false;
		for (Task task:this.google.getTaskList()) {
			if (!task.isDeleted() && task.equals(testTask)) success = true;
		}
		assertTrue(success);
		this.google.deleteTask(testTask);
		for (Task task:this.google.getTaskList()) {
			if (!task.isDeleted() && task.equals(testTask)) fail();
		}
	}
	
	//Test for invalid input
	@Test(expected = HandledException.class)
	public void testNullAdd() throws HandledException, IOException {
		this.google.addTask(null);
	}
	
	//Test for invalid input
	@Test(expected = HandledException.class)
	public void testNullUpdate() throws HandledException, IOException {
		this.google.updateTask(null);
	}
	
	//Test for invalid input
	@Test(expected = HandledException.class)
	public void testNullDelete() throws HandledException, IOException {
		this.google.deleteTask(null);
	}
}

	// End of segment: CEO\src\cs2103\storage\GoogleEngineTest.java





	/**
	 * origin: CEO\src\cs2103\storage\GoogleReceiver.java
	 */

package cs2103.storage;

import java.awt.Desktop;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URI;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Collection;

import com.google.api.client.auth.oauth2.AuthorizationCodeFlow;
import com.google.api.client.auth.oauth2.AuthorizationCodeRequestUrl;
import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.auth.oauth2.TokenResponse;
import com.google.api.client.extensions.java6.auth.oauth2.VerificationCodeReceiver;
import com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver;
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.http.HttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.jackson2.JacksonFactory;
import com.google.api.client.util.Preconditions;
import com.google.api.services.calendar.CalendarScopes;
import com.google.api.services.tasks.TasksScopes;

import cs2103.util.CommonUtil;
import cs2103.util.Logger;

/**
 * This class utilizes Google's OAuth2 method to get credentials.
 */
public class GoogleReceiver {
	private static final String APPLICATION_NAME = "cs2103-CEO/1.0";
	private static final String client_secret = "{\"installed\":{\"auth_uri\":\"https://accounts.google.com/o/oauth2/auth\",\"client_secret\":\"zCMOqFnPqBLS-jLR7q2p1LGt\",\"token_uri\":\"https://accounts.google.com/o/oauth2/token\",\"client_email\":\"\",\"redirect_uris\":[\"urn:ietf:wg:oauth:2.0:oob\",\"oob\"],\"client_x509_cert_url\":\"\",\"client_id\":\"179875106660-efg7a9ehbjv4lcq2pohh1hd1npgdp1fp.apps.googleusercontent.com\",\"auth_provider_x509_cert_url\":\"https://www.googleapis.com/oauth2/v1/certs\"}}";
	private static final String userId = "user";
	private static final String LOGIN_LOG = "Trying to authorize for Google Sync";
	private final Logger logger;
	private final JsonFactory JSON_FACTORY;
	private final Collection<String> scopes;
	private final GoogleClientSecrets clientSecrets;
	private final AuthorizationCodeFlow flow;
	private final VerificationCodeReceiver receiver;
	private HttpTransport httpTransport;
	private AuthStoreFactory dataStoreFactory;
	
	/**
	 * @throws IOException
	 * @throws GeneralSecurityException
	 * Use AuthorizationCodeFlow to authorize this program to access data on Google
	 */
	public GoogleReceiver() throws IOException, GeneralSecurityException {
		this.logger = Logger.getInstance();
		this.dataStoreFactory = new AuthStoreFactory();
		this.JSON_FACTORY = JacksonFactory.getDefaultInstance();
		this.httpTransport = GoogleNetHttpTransport.newTrustedTransport();
	    this.scopes = new ArrayList<String>();
	    this.scopes.add(CalendarScopes.CALENDAR);
	    this.scopes.add(TasksScopes.TASKS);
	    this.receiver = new LocalServerReceiver();
	    this.clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(new ByteArrayInputStream(client_secret.getBytes())));
	    this.flow = new GoogleAuthorizationCodeFlow.Builder(httpTransport, JSON_FACTORY, clientSecrets, scopes).setDataStoreFactory(dataStoreFactory).build();
	    this.authorize();
	}
	
	private Credential authorize() throws IOException {
		try{
			Credential credential = this.flow.loadCredential(userId);
			if (credential != null && (credential.getRefreshToken() != null || credential.getExpiresInSeconds() > 60)) {
				return credential;
			}
			this.logger.writeLog(LOGIN_LOG);
			String redirectUri = this.receiver.getRedirectUri();
			onAuthorization(flow.newAuthorizationUrl().setRedirectUri(redirectUri));
			String code = this.receiver.waitForCode();
			TokenResponse response = this.flow.newTokenRequest(code).setRedirectUri(redirectUri).execute();
			return this.flow.createAndStoreCredential(response, userId);
		} finally {
			this.receiver.stop();
		}
	}
	
	/**
	 * @return A Google Calendar client
	 * @throws IOException
	 */
	public com.google.api.services.calendar.Calendar getCalendarClient() throws IOException{
		return new com.google.api.services.calendar.Calendar.Builder(this.httpTransport, this.JSON_FACTORY, this.authorize()).setApplicationName(APPLICATION_NAME).build();
	}
	
	/**
	 * @return A Google Tasks client
	 * @throws IOException
	 */
	public com.google.api.services.tasks.Tasks getTasksClient() throws IOException{
		return new com.google.api.services.tasks.Tasks.Builder(this.httpTransport, this.JSON_FACTORY, this.authorize()).setApplicationName(APPLICATION_NAME).build();
	}
	
	private void onAuthorization(AuthorizationCodeRequestUrl authorizationUrl) throws IOException{
	    String url = authorizationUrl.build();
	    Preconditions.checkNotNull(url);
	    CommonUtil.print("Please open the following address in your browser:\n");
	    CommonUtil.print(url + "\n");
	    if (CommonUtil.checkSyncSupport()) {
	    	Desktop desktop = Desktop.getDesktop();
	    	CommonUtil.print("Attempting to open that address in the default browser now...\n");
	    	desktop.browse(URI.create(url));
	    } else {
	    	throw new IOException("Login failed");
	    }
	}
}

	// End of segment: CEO\src\cs2103\storage\GoogleReceiver.java





	/**
	 * origin: CEO\src\cs2103\storage\StorageEngine.java
	 */

package cs2103.storage;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.task.DeadlineTask;
import cs2103.task.FloatingTask;
import cs2103.task.PeriodicTask;
import cs2103.task.Task;
import cs2103.task.ToDoTask;
import cs2103.util.CommonUtil;
import cs2103.util.Logger;

import java.util.Collections;

import net.fortuna.ical4j.data.CalendarBuilder;
import net.fortuna.ical4j.data.CalendarOutputter;
import net.fortuna.ical4j.data.ParserException;
import net.fortuna.ical4j.model.Component;
import net.fortuna.ical4j.model.IndexedComponentList;
import net.fortuna.ical4j.model.Property;
import net.fortuna.ical4j.model.Recur;
import net.fortuna.ical4j.model.TimeZone;
import net.fortuna.ical4j.model.TimeZoneRegistry;
import net.fortuna.ical4j.model.TimeZoneRegistryFactory;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.component.VToDo;
import net.fortuna.ical4j.model.property.CalScale;
import net.fortuna.ical4j.model.property.Created;
import net.fortuna.ical4j.model.property.LastModified;
import net.fortuna.ical4j.model.property.ProdId;
import net.fortuna.ical4j.model.property.RRule;
import net.fortuna.ical4j.model.property.Version;
import net.fortuna.ical4j.model.ValidationException;
import net.fortuna.ical4j.util.CompatibilityHints;

/**
 * This class implements StorageInterface
 * Using iCal4j to read and store iCalendar file complying RFC 2445 iCalendar specification
 */
public class StorageEngine implements StorageInterface{
	private net.fortuna.ical4j.model.Calendar calendar;
	private IndexedComponentList indexedComponents;
	private final File file;
	private final Logger logger;
	private static final String LOG_INITIALIZE = "Initializing StorageEngine";
	private static final String LOG_NEWFILE = "Creating new storage file";
	private static final String LOG_ADD = "Adding task with UID %1$s to file";
	private static final String LOG_UPDATE = "Updating task with UID %1$s to file";
	private static final String LOG_REMOVE = "Removing task with UID %1$s from file";
	
	public StorageEngine(File file) throws HandledException, FatalException {
		this.logger = Logger.getInstance();
		this.logger.writeLog(LOG_INITIALIZE);
		if (file == null) {
			throw new FatalException(FatalException.ExceptionType.ILLEGAL_FILE);
		}
		CompatibilityHints.setHintEnabled(CompatibilityHints.KEY_RELAXED_VALIDATION, true);
		this.file = file;
		readFromFile();
	}
	
	private void createNewFile() throws HandledException, FatalException {
		this.logger.writeLog(LOG_NEWFILE);
		this.calendar = new net.fortuna.ical4j.model.Calendar();
		this.calendar.getProperties().add(new ProdId("-//cs2103-f11-2j//CEO 0.4//EN"));
		this.calendar.getProperties().add(Version.VERSION_2_0);
		this.calendar.getProperties().add(CalScale.GREGORIAN);
		TimeZoneRegistry registry = TimeZoneRegistryFactory.getInstance().createRegistry();
		TimeZone timeZone = registry.getTimeZone(TimeZone.getDefault().getID());
		this.calendar.getComponents().add(timeZone.getVTimeZone());
		writeToFile();
	}
	
	private ArrayList<Task> readFromFile() throws FatalException, HandledException {
		try{
			FileInputStream fin = new FileInputStream(this.file);
			CalendarBuilder builder = new CalendarBuilder();
			this.calendar = builder.build(fin);
			this.indexedComponents = new IndexedComponentList(this.calendar.getComponents(), Property.UID);
			return this.parseTaskList();
		} catch (FileNotFoundException e) {
			this.createNewFile();
			return this.readFromFile();
		} catch(IOException e) {
			throw new FatalException(FatalException.ExceptionType.READ_ERROR);
		} catch (ParseException | ParserException e) {
			throw new FatalException(FatalException.ExceptionType.ILLEGAL_FILE);
		}
	}
	
	@SuppressWarnings("unchecked") 
	private ArrayList<Task> parseTaskList() throws ParseException, HandledException, FatalException {
		assert(this.calendar != null);
		ArrayList<Task> taskList = new ArrayList<Task>();
		for (Iterator<VToDo> i = this.calendar.getComponents(Component.VTODO).iterator(); i.hasNext();) {
			VToDo component = i.next();
			taskList.add(parseVToDo(component));
		}
		for (Iterator<VEvent> i = this.calendar.getComponents(Component.VEVENT).iterator(); i.hasNext();) {
			VEvent component = i.next();
			taskList.add(parseVEvent(component));
		}
		return sortTaskList(taskList);
	}

	private void writeToFile() throws HandledException, FatalException {
		try {
			this.calendar.validate();
			FileOutputStream fout;
			fout = new FileOutputStream(this.file);
			CalendarOutputter outputter = new CalendarOutputter();
			outputter.output(this.calendar, fout);
		} catch (FileNotFoundException e) {
			this.createNewFile();
			this.writeToFile();
		} catch (IOException | ValidationException e) {
			throw new FatalException(FatalException.ExceptionType.WRITE_ERROR);
		}
	}
	
	/**
	 * Add the Task object into file if a Task with the same UID does not exist, update if it does
	 * @param Task
	 * @throws HandledException
	 * @throws FatalException
	 */
	@Override
	public void updateTask(Task task) throws HandledException, FatalException {
		if (task != null){
			assert(this.indexedComponents != null);
			Component updating = task.toComponent();
			Component existing = this.indexedComponents.getComponent(task.getTaskUID());
			if (existing == null) {
				this.logger.writeLog(CommonUtil.formatLogString(LOG_ADD, task));
				this.calendar.getComponents().add(updating);
			} else {
				this.logger.writeLog(CommonUtil.formatLogString(LOG_UPDATE, task));
				this.calendar.getComponents().remove(existing);
				this.calendar.getComponents().add(updating);
			}
			writeToFile();
		}
	}
	
	/**
	 * Delete the Task from the file if it does exist
	 * @param Task
	 * @throws HandledException
	 * @throws FatalException
	 */
	@Override
	public void deleteTask(Task task) throws HandledException, FatalException {
		if (task != null) {
			assert(this.indexedComponents != null);
			this.logger.writeLog(CommonUtil.formatLogString(LOG_REMOVE, task));
			Component existing = this.indexedComponents.getComponent(task.getTaskUID());
			if (existing == null) {
				throw new HandledException(HandledException.ExceptionType.TASK_NOT_EXIST);
			} else {
				this.calendar.getComponents().remove(existing);
			}
			writeToFile();
		}
	}

	/**
	 * @return The most up-to-date Task list
	 * @throws HandledException
	 * @throws FatalException
	 */
	@Override
	public ArrayList<Task> getTaskList() throws FatalException, HandledException {
		return this.readFromFile();
	}
	
	private Task parseVEvent(VEvent component) throws ParseException, FatalException, HandledException {
		assert(component != null);
		String componentUID = this.readUid(component);
		Date[] componentPeriod = this.readPeriod(component);
		PeriodicTask task = new PeriodicTask(componentUID, component.getStatus(), componentPeriod[0], componentPeriod[1]);
		task.updateTitle(this.readTitle(component));
		task.updateCreated(this.readCreated(component));
		task.updateLocation(this.readLocation(component));
		task.updateRecurrence(this.readRecur(component));
		task.updateDescription(this.readDescription(component));
		task.updateLastModified(this.readLastModified(component));
		return task;
	}
	
	private Task parseVToDo(VToDo component) throws ParseException, HandledException, FatalException {
		assert(component != null);
		ToDoTask task;
		String componentUID = this.readUid(component);
		if (component.getDue() == null) {
			task = new FloatingTask(componentUID, component.getStatus());
		}else{
			task = new DeadlineTask(componentUID, component.getStatus(), component.getDue().getDate());
		}
		task.updateTitle(this.readTitle(component));
		task.updateCreated(this.readCreated(component));
		task.updateCompleted(this.readCompleted(component));
		task.updateDescription(this.readDescription(component));
		task.updateLastModified(this.readLastModified(component));
		return task;
	}
	
	private Date[] readPeriod(VEvent component) throws FatalException {
		assert(component != null);
		if (component.getStartDate() == null || component.getEndDate() == null) {
			throw new FatalException(FatalException.ExceptionType.ILLEGAL_FILE);
		}else{
			Date[] period = new Date[2];
			period[0] = component.getStartDate().getDate();
			period[1] = component.getEndDate().getDate();
			return period;
		}
	}
	
	private Date readCreated(Component component) {
		assert(component != null);
		if (component.getProperty(Property.CREATED) == null) {
			return null;
		} else {
			return ((Created) component.getProperty(Property.CREATED)).getDateTime();
		}
	}
	
	private Date readLastModified(Component component) {
		assert(component != null);
		if (component.getProperty(Property.LAST_MODIFIED) == null) {
			return null;
		} else {
			return ((LastModified) component.getProperty(Property.LAST_MODIFIED)).getDateTime();
		}
	}
	
	private String readUid(Component component) {
		assert(component != null);
		if (component.getProperty(Property.UID) == null) {
			return null;
		}else{
			return component.getProperty(Property.UID).getValue();
		}
	}
	
	private String readTitle(Component component) {
		assert(component != null);
		if (component.getProperty(Property.SUMMARY) == null) {
			return "";
		}else{
			return component.getProperty(Property.SUMMARY).getValue();
		}
	}
	
	private Date readCompleted(VToDo component) {
		assert(component != null);
		if (component.getDateCompleted() == null) {
			return null;
		}else{
			return component.getDateCompleted().getDateTime();
		}
	}
	
	private Recur readRecur(VEvent component) {
		assert(component != null);
		if (component.getProperty(Property.RRULE) == null) {
			return null;
		}else{
			RRule rule = (RRule) component.getProperty(Property.RRULE);
			return rule.getRecur();
		}
	}
	
	private String readDescription(Component component) {
		assert(component != null);
		if (component.getProperty(Property.DESCRIPTION) == null) {
			return "";
		}else{
			return component.getProperty(Property.DESCRIPTION).getValue();
		}
	}
	
	private String readLocation(VEvent component) {
		assert(component != null);
		if (component.getLocation() == null) {
			return "";
		}else{
			return component.getLocation().getValue();
		}
	}
	
	private ArrayList<Task> sortTaskList(ArrayList<Task> taskList) {
		assert(taskList != null);
		Collections.sort(taskList);
		int count=0;
		for (Task task:taskList) {
			count++;
			task.updateTaskID(count);
		}
		return taskList;
	}
}

	// End of segment: CEO\src\cs2103\storage\StorageEngine.java





	/**
	 * origin: CEO\src\cs2103\storage\StorageEngineTest.java
	 */

package cs2103.storage;

import static org.junit.Assert.*;

import java.io.File;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Before;
import org.junit.Test;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.task.*;
import cs2103.util.TestUtil;

public class StorageEngineTest {
	StorageEngine storage;
	File file = new File("Test.ics");
	
	@Before
	public void before() throws HandledException, FatalException {
		file.delete();
		this.storage = new StorageEngine(file);
	}
	
	@Test
	public void testAddNewTask() throws HandledException, FatalException {
		Task task1 = new FloatingTask(null, null);
		task1.updateTitle("I feel my body is so light");
		task1.updateDescription("I have never feel such way before");
		Task task2 = new DeadlineTask(null, null, new Date());
		task2.updateTitle("Nothing to be afraid of any more");
		task2.updateDescription("Because I am no longer alone");
		Task task3 = new PeriodicTask(null, null, new Date(System.currentTimeMillis()), new Date(System.currentTimeMillis() + 864000L));
		task3.updateTitle("Tiro Finale");
		task3.updateDescription("If every Puella Magi will become a witch, why not we die now");
		task3.updateLocation("Mitakihara");
		storage.updateTask(task1);
		storage.updateTask(task2);
		storage.updateTask(task3);
		ArrayList<Task> testList = storage.getTaskList();
		assertEquals(3, testList.size());
		for (Task task:testList) {
			if (task.equals(task1)) assertTrue(TestUtil.compareTasks(task, task1));
			if (task.equals(task2)) assertTrue(TestUtil.compareTasks(task, task2));
			if (task.equals(task3)) assertTrue(TestUtil.compareTasks(task, task3));
		}
	}
	
	@Test
	public void testUpdateTask() throws HandledException, FatalException {
		ArrayList<Task> testList = storage.getTaskList();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		for (Task task:testList) {
			expectedList.add(task);
		}
		for (Task task:expectedList) {
			task.updateTitle(task.getTaskUID());
			storage.updateTask(task);
		}
		testList = storage.getTaskList();
		for (Task task:testList){
			for (Task expected:expectedList) {
				if (expected.equals(task)) {
					assertTrue(TestUtil.compareTasks(task, expected));
				}
			}
		}
	}
	
	@Test
	public void testDeleteTask() throws FatalException, HandledException {
		ArrayList<Task> testList = storage.getTaskList();
		for (Task task:testList) {
			storage.deleteTask(task);
		}
		testList = storage.getTaskList();
		assertEquals(0, testList.size());
	}
}

	// End of segment: CEO\src\cs2103\storage\StorageEngineTest.java





	/**
	 * origin: CEO\src\cs2103\storage\StorageInterface.java
	 */

package cs2103.storage;

import java.util.ArrayList;

import cs2103.exception.FatalException;
import cs2103.exception.HandledException;
import cs2103.task.Task;

public interface StorageInterface {
	/**
	 * Delete the task from storage
	 * @param Task
	 * @throws HandledException
	 * @throws FatalException
	 */
	public void deleteTask(Task task) throws HandledException, FatalException;
	/**
	 * Add the Task object into file if a Task with the same UID does not exist, update if it does
	 * @param Task
	 * @throws HandledException
	 * @throws FatalException
	 */
	public void updateTask(Task task) throws HandledException, FatalException;
	/**
	 * @return The most up-to-date Task list
	 * @throws FatalException
	 * @throws HandledException
	 */
	public ArrayList<Task> getTaskList() throws FatalException, HandledException;
}

	// End of segment: CEO\src\cs2103\storage\StorageInterface.java





	/**
	 * origin: CEO\src\cs2103\storage\StorageStub.java
	 */

package cs2103.storage;

import java.util.ArrayList;
import java.util.Collections;

import cs2103.task.Task;

/**
 * This class is used for testing purpose, it will not write the task list into file system
 */
public class StorageStub implements StorageInterface {
	private ArrayList<Task> tasks;
	
	public StorageStub() {
		this.tasks = new ArrayList<Task>();
	}
	
	/**
	 * @see cs2103.storage.StorageInterface#deleteTask(cs2103.task.Task)
	 */
	@Override
	public void deleteTask(Task task) {
		Task existing = this.getModifyingTask(task);
		if (existing != null) {
			this.tasks.remove(existing);
		}
	}
	
	/**
	 * @see cs2103.storage.StorageInterface#updateTask(cs2103.task.Task)
	 */
	@Override
	public void updateTask(Task task) {
		this.deleteTask(task);
		this.tasks.add(task);
	}
	
	/**
	 * @see cs2103.storage.StorageInterface#getTaskList()
	 */
	@Override
	public ArrayList<Task> getTaskList() {
		sortTasks();
		return this.tasks;
	}
	
	private void sortTasks() {
		Collections.sort(this.tasks);
		int count=0;
		for (Task task:this.tasks) {
			count++;
			task.updateTaskID(count);
		}
	}
	
	private Task getModifyingTask(Task task){
		for (Task existing:this.tasks){
			if (existing.equals(task)){
				return existing;
			}
		}
		return null;
	}
}

	// End of segment: CEO\src\cs2103\storage\StorageStub.java





	/**
	 * origin: CEO\src\cs2103\TestAll.java
	 */

package cs2103;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;
import cs2103.command.*;
import cs2103.parameters.*;
import cs2103.task.*;
import cs2103.storage.*;
import cs2103.util.*;

@RunWith(Suite.class)
@SuiteClasses({CommandLineUITest.class,
	AddTest.class, AlertTest.class, DeleteTest.class, HelpTest.class, ListTest.class, MarkTest.class, RestoreTest.class, SearchTest.class, ShowTest.class, SyncTest.class, UpdateTest.class, UpdateTimeFromRecurTest.class,
	CommandTypeTest.class, CompleteTest.class, DeleteOptionTest.class, DescriptionTest.class, KeywordTest.class, LocationTest.class, OptionTest.class, ParameterListTest.class, RecurrenceTest.class, TaskIDTest.class, TaskTypeTest.class, TimeTest.class, TitleTest.class,
	DeadlineTaskTest.class, FloatingTaskTest.class, PeriodicTaskTest.class,
	StorageEngineTest.class, GoogleEngineTest.class, TaskListTest.class,
	CommonUtilTest.class})
public class TestAll {

}

	// End of segment: CEO\src\cs2103\TestAll.java





	/**
	 * origin: CEO\src\cs2103\util\Console.java
	 */

package cs2103.util;

/**
 * Clear console on Windows
 */
public class Console {
	/* cs2103_util_Console.h
	 #include <jni.h>
	 #ifndef _Included_cs2103_util_Console
	 #define _Included_cs2103_util_Console
	 #ifdef __cplusplus
	 extern "C" {
	 #endif
	 JNIEXPORT void JNICALL Java_cs2103_util_Console_clr(JNIEnv *, jclass);
	 #ifdef __cplusplus
	 }
	 #endif
	 #endif
	 */
	static {
		if (System.getProperty("os.arch").contains("64")) {
			System.loadLibrary("lib/ConsoleClear_x64");
		} else {
			System.loadLibrary("lib/ConsoleClear_x86");
		}
	}
	/* cs2103_util_Console.c
	 #include <windows.h>
	 #include <jni.h>
	 #include "cs2103_util_Console.h"

	 #ifdef __cplusplus
	 extern "C" {
	 #endif
		JNIEXPORT void JNICALL Java_cs2103_util_Console_clr(JNIEnv *env, jclass thisClass){
       		HANDLE chwnd = GetStdHandle(STD_OUTPUT_HANDLE);
       		COORD coordScreen = { 0, 0 };
       		DWORD cCharsWritten;
       		{
           		WORD textColours;
           		CONSOLE_SCREEN_BUFFER_INFO *consoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
           		GetConsoleScreenBufferInfo(chwnd, consoleInfo);
           		textColours = consoleInfo->wAttributes;
           		SetConsoleTextAttribute(chwnd, textColours);
       		}
       		CONSOLE_SCREEN_BUFFER_INFO csbi;
       		DWORD dwConSize;
       		if( !GetConsoleScreenBufferInfo( chwnd, &csbi )) return;
       		dwConSize = csbi.dwSize.X * csbi.dwSize.Y;
       		if( !FillConsoleOutputCharacter( chwnd, (TCHAR) ' ', dwConSize, coordScreen, &cCharsWritten )) return;
       		if( !GetConsoleScreenBufferInfo( chwnd, &csbi )) return;
       		if( !FillConsoleOutputAttribute( chwnd, csbi.wAttributes, dwConSize, coordScreen, &cCharsWritten )) return;
       		SetConsoleCursorPosition( chwnd, coordScreen );
       		return;
		}
		
	 #ifdef __cplusplus
	 }
	 #endif
	 */
	public static native void clr();
}

	// End of segment: CEO\src\cs2103\util\Console.java





	/**
	 * origin: CEO\src\cs2103\util\Logger.java
	 */

package cs2103.util;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Date;

/**
 * Log message to file
 */
public class Logger {
	private static Logger logger;
	private final File error;
	private final File log;
	
	private Logger() {
		this.error = new File("CEOError.log");
		this.log = new File("CEOLog.log");
	}
	
	public static Logger getInstance() {
		if (logger == null) {
			logger = new Logger();
		}
		return logger;
	}
	
	/**
	 * Write StackTrace to error log
	 * @param errorMsg
	 * @param exception
	 */
	public void writeErrLog(String errorMsg, Exception exception) {
		PrintWriter pw = null;
		try {
			pw = new PrintWriter(new BufferedWriter(new FileWriter(this.error, true)));
			pw.println(new Date());
			pw.println(errorMsg);
			exception.printStackTrace(pw);
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (pw != null) pw.close();
		}
	}
	
	/**
	 * Write log message to log file
	 * @param logMsg
	 */
	public void writeLog(String logMsg) {
		PrintWriter pw = null;
		try {
			pw = new PrintWriter(new BufferedWriter(new FileWriter(this.log, true)));
			pw.print(new Date());
			pw.print(":\t");
			pw.println(logMsg);
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (pw != null) pw.close();
		}
	}
}

	// End of segment: CEO\src\cs2103\util\Logger.java





